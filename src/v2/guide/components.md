---
title: Компоненты
type: guide
order: 11
---

## Что такое Компоненты?

Компоненты представляют собой одну из самых мощных возможностей Vue. Они могут помочь вам расширить базовые HTML элементы и инкапсулировать повторно используемый код. На высоком уровне, компоненты представляют из себя пользовательские элементы, к которым компилятор Vue привязывает некоторое поведение. В некоторых случаях они также могут проявляться как нативные HTML элементы, расширенные при помощи специального аттрибута `is`.

## Использование Компонентов

### Регистрация

В предыдущих секциях мы научились создавать инстансы Vue:

``` js
new Vue({
  el: '#some-element',
  // опции
})
```

Для создания глобального компонента, вы можете использовать `Vue.component(tagName, options)`. Например:

``` js
Vue.component('my-component', {
  // опции
})
```

<p class="tip">Обратите внимание, что Vue не требует соблюдения [правил W3C](http://www.w3.org/TR/custom-elements/#concepts) для пользовательских имён тегов (таких как использование только нижнего регистра и необходимость наличия дефиса), хотя следование этим соглашением считается хорошей практикой.</p>

После регистрации, компонент может быть использован в шаблоне инстанса в качестве пользовательского компонента `<my-component></my-component>`. Удостоверьтесь, что регистрация компонента происходит **до** создания корневого инстанса Vue. Вот полный пример:

``` html
<div id="example">
  <my-component></my-component>
</div>
```

``` js
// регистрация
Vue.component('my-component', {
  template: '<div>Пользовательский компонент!</div>'
})

// создание корневого инстанса
new Vue({
  el: '#example'
})
```

Результатом рендеринга будет:

``` html
<div id="example">
  <div>Пользовательский компонент!</div>
</div>
```

{% raw %}
<div id="example" class="demo">
  <my-component></my-component>
</div>
<script>
Vue.component('my-component', {
  template: '<div>Пользовательский компонент!</div>'
})
new Vue({ el: '#example' })
</script>
{% endraw %}

### Локальная Регистрация

Необязательно регистрировать компоненты глобально. Можно сделать компонент доступным только в области видимости другого инстанса/компонента, зарегистрировав его через опцию `components`:

``` js
var Child = {
  template: '<div>Пользовательский компонент!</div>'
}

new Vue({
  // ...
  components: {
    // <my-component> будет доступен только в шаблоне родителя
    'my-component': Child
  }
})
```

Аналогичные правила инкапсуляции применимы для всех остальных доступных для регистрации пользовательских расширений Vue, таких как директивы.

### Возможные Неприятности при Парсинге DOM

При использовании DOM в качестве шаблона (то есть указывая через опцию `el` точку монтирования в элемент, уже содержащий контент), вам придётся столкнутся с рядом ограничений, унаследованных от самого механизма работы HTML, так как Vue может получить содержимое шаблона только **после** того, как браузер распарсил и нормализовал его. Больше всего заметны ограничения таких элементов как `<ul>`, `<ol>`, `<table>` и `<select>` на то, какие элементы могут находиться внутри. Некоторые элементы, например `<option>` напротив, могут находится только внутри элементов конкретных типов.

Это приводит к неудобствам при использовании пользовательских компонентов вместе с подобным образом ограниченными элементами, например:

``` html
<table>
  <my-row>...</my-row>
</table>
```

Пользовательский компонент `<my-row>` будет выкинут как некорректный, провоцируя таким образом ошибки при дальнейшем рендеринге. Обойти эту проблему можно используя специальный аттрибут `is`:

``` html
<table>
  <tr is="my-row"></tr>
</table>
```

**Стоит заметить, что эти ограничения неприменимы при использовании шаблонов из одного и перечисленных ниже источников**:

- `<script type="text/x-template">`
- inline-строки JavaScript
- `.vue`-компоненты

Поэтому, по возможности всегда используйте строковые шаблоны.

### `data` Должна Быть Функцией

Большая часть опций, которые можно передать в конструктор Vue могут быть использованы и в компоненте, с одной важной деталью: `data` должна быть функцией. В действительности, если вы попробуете запустить такой код:

``` js
Vue.component('my-component', {
  template: '<span>{{ message }}</span>',
  data: {
    message: 'hello'
  }
})
```

Vue остановится и выведет в консоль предупреждения, говорящие о том что `data` в компонентах должна быть функцией. Тем не менее, неплохо понимать, из-за чего существуют правила — так что давайте схитрим.

``` html
<div id="example-2">
  <simple-counter></simple-counter>
  <simple-counter></simple-counter>
  <simple-counter></simple-counter>
</div>
```

``` js
var data = { counter: 0 }

Vue.component('simple-counter', {
  template: '<button v-on:click="counter += 1">{{ counter }}</button>',
  // технически data является функцией, так что Vue
  // не будет жаловаться, но эта функция неизменно
  // возвращает ссылку на один и тот же внешний объект
  data: function () {
    return data
  }
})

new Vue({
  el: '#example-2'
})
```

{% raw %}
<div id="example-2" class="demo">
  <simple-counter></simple-counter>
  <simple-counter></simple-counter>
  <simple-counter></simple-counter>
</div>
<script>
var data = { counter: 0 }
Vue.component('simple-counter', {
  template: '<button v-on:click="counter += 1">{{ counter }}</button>',
  data: function () {
    return data
  }
})
new Vue({
  el: '#example-2'
})
</script>
{% endraw %}

Поскольку все три инстанса компонента основываются на одном и том же объекте `data`, инкремент одного из счётчиков инкрементирует их все. Ой. Давайте исправим это, возвращая каждый раз свежесозданный объект:

``` js
data: function () {
  return {
    counter: 0
  }
}
```

Теперь у всех наших счётчиков есть их собственное внутреннее состояние:

{% raw %}
<div id="example-2-5" class="demo">
  <my-component></my-component>
  <my-component></my-component>
  <my-component></my-component>
</div>
<script>
Vue.component('my-component', {
  template: '<button v-on:click="counter += 1">{{ counter }}</button>',
  data: function () {
    return {
      counter: 0
    }
  }
})
new Vue({
  el: '#example-2-5'
})
</script>
{% endraw %}

### Композиция Компонентов

Компоненты созданы для совместного использования, в основном в рамках отношений родитель-потомок: компонент А может использовать компонент Б в своём собственном шаблоне. Неизбежно, появляется необходимость в коммуникации компонентов друг с другом: родителю может понадобиться передать данные в дочерний компонент, а тому, в свою очередь, может понадобиться проинформировать родителя о том что что-то произошло. Вместе с тем, очень важно минимизировать взаимное влияние компонентов друг на друга, для чего требуется ясно определённый интерфейс. Таким образом можно удостоверится, что код каждого компонента может быть написан и проанализирован в условиях относительной изоляции, что упрощает поддержку и потенциально облегчает их повторное использование.

Во Vue.js, отношения родитель-ребёнок могут быть кратко просуммированы формулой **входные параметры — вниз, события — вверх ("props down, events up")**. Родитель передаёт данные потомку через **props**, а потомок посылает сообщения родителю посредством **событий**. Давайте посмотрим, как это работает.

<p style="text-align: center">
  <img style="width:300px" src="/images/props-events.png" alt="props down, events up">
</p>

## Входные Параметры

### Передача Данных через Входные Параметры

Каждый инстанс компонента обладает своей собственной **изолированной областью видимости**. Это значит, что вы не можете (и не должны пытаться) напрямую обратиться к данным родительского компонента из шаблона компонента-потомка. Данные можно передавать вниз по цепочке как **входных параметров**.

Входной Параметр — это пользовательский аттрибут для передачи информации из родительского компонента. Компонент-потомок должен явно определить ожидаемые входные параметры, используя [опцию `props`](../api/#props)

``` js
Vue.component('child', {
  // определяем входной параметр
  props: ['message'],
  // как и другие данные, входной параметр можно использовать
  // внутри шаблонов и в vm, обращаясь через this.message)
  template: '<span>{{ message }}</span>'
})
```

Затем мы можем передать в компонент строку, например так:

``` html
<child message="hello!"></child>
```

Результатом будет:

{% raw %}
<div id="prop-example-1" class="demo">
  <child message="hello!"></child>
</div>
<script>
new Vue({
  el: '#prop-example-1',
  components: {
    child: {
      props: ['message'],
      template: '<span>{{ message }}</span>'
    }
  }
})
</script>
{% endraw %}

### camelCase vs. kebab-case

Аттрибуты HTML являются регистронезависимыми, так что при использовании в DOM в качестве шаблона вместо camelCase-версий имён входных параметров приходится применять их kebab-case эквиваленты (разделять слова дефисом):

``` js
Vue.component('child', {
  // camelCase в JavaScript
  props: ['myMessage'],
  template: '<span>{{ myMessage }}</span>'
})
```

``` html
<!-- kebab-case в HTML -->
<child my-message="hello!"></child>
```

Впрочем, строковые шаблоны не накладывают и этого ограничения.

### Динамические Входные Параметры

Подобно связыванию обычных аттрибутов, допустимо и динамическое связывание входных параметров с данными родительского компонента. Любое обновление данных в родителе в этом случае будет передано и в потомка:

``` html
<div>
  <input v-model="parentMsg">
  <br>
  <child v-bind:my-message="parentMsg"></child>
</div>
```

Зачастую проще использовать для `v-bind` сокращённую запись:

``` html
<child :my-message="parentMsg"></child>
```

Результат:

{% raw %}
<div id="demo-2" class="demo">
  <input v-model="parentMsg">
  <br>
  <child v-bind:my-message="parentMsg"></child>
</div>
<script>
new Vue({
  el: '#demo-2',
  data: {
    parentMsg: 'Message from parent'
  },
  components: {
    child: {
      props: ['myMessage'],
      template: '<span>{{myMessage}}</span>'
    }
  }
})
</script>
{% endraw %}

### Строковые vs Динамические Параметры

Частой ошибкой новичков является попытка передать в качестве параметра компонента число, используя строковой синтаксис:

``` html
<!-- при такой записи в компонент будет передана строка "1" -->
<comp some-prop="1"></comp>
```

Однако, поскольку используется строковой параметр, в компонент вместо числа будет передано значение строки `"1"`. Для передачи числа придётся использовать директиву `v-bind`, так как её значение вычисляется как выражение JavaScript:

``` html
<!-- этот синтаксис позволит передать в компонент число -->
<comp v-bind:some-prop="1"></comp>
```

### Однонаправленный Поток Данных

Входные параметры создают **однонаправленный** поток данных между родительскими и дочерними компонентами: обновление свойств родителя будет передано в дочерний компонент, но обратное — не случится. Это предотвращает случайное изменение родительских данных дочерними компонентами, которое затруднило бы размышления о потоке данных вашего приложения.

Кроме того, при любом обновлении родительского компонента, все входные параметры дочерних компонентов также обновляются до свежего значения. Поэтому *не* стоит пробовать изменять значения входных параметров внутри компонента. Если вы всё же захотите это сделать, Vue отреагирует предупреждением в консоли.

Желание изменить значение входного параметра обычно возникает в двух случаях:

1. Входной параметр используется лишь для передачи изначального значения, после чего дочерний компонент хотел бы использовать эту переменную как локальную.

2. Входной параметр передаётся как необработанное значение, требующее обработки.

Правильным ответом в этих случаях будет:

1. Определить локальную переменную, использующую для инициализации значение входного параметра:

  ``` js
  props: ['initialCounter'],
  data: function () {
    return { counter: this.initialCounter }
  }
  ```

2. Определить вычисляемое свойство, основывающееся на значении входного параметра:

  ``` js
  props: ['size'],
  computed: {
    normalizedSize: function () {
      return this.size.trim().toLowerCase()
    }
  }
  ```

<p class="tip">Обратите внимание, что объекты и массивы в JavaScript передаются по ссылке, так что если входным параметром является объект или массив, его изменение внутри дочернего компонента **повлияет** на состояние родительского компонента.</p>

### Валидация Входных Параметров

Компонент может указать не только список ожидаемых параметров, но предъявляемые к ним требования. В случае, если переданные параметры не будут удовлетворять этим требованиям, Vue отреагирует предупреждениями. Эта возможность особенна полезна при создании компонентов, предназначающихся для использования другими людьми.

Вместо определения параметров как массива строк, вы можете использовать объект с правилами валидации:

``` js
Vue.component('example', {
  props: {
    // простая проверка типа (`null` означает допустимость любого типа)
    propA: Number,
    // несколько допустимых типов
    propB: [String, Number],
    // обязательное значение строкового типа
    propC: {
      type: String,
      required: true
    },
    // число со значением по умолчанию
    propD: {
      type: Number,
      default: 100
    },
    // значения по умолчанию для объектов/массивов должны
    // быть возвращаемыми значениями функций
    propE: {
      type: Object,
      default: function () {
        return { message: 'hello' }
      }
    },
    // пользовательская функция для валидации
    propF: {
      validator: function (value) {
        return value > 10
      }
    }
  }
})
```

Параметр типа `type` должен принимать одно из нижеперечисленных нативных значений:

- String
- Number
- Boolean
- Function
- Object
- Array

Кроме того, `type` может быть и пользовательской функцией — проверка будет выполняться вызовом `instanceof`.

В случае ошибки валидации, Vue выбросит предупреждение в консоль (при использовании development-сборки).

## Пользовательские События

Мы узнали, что родитель может передавать данные в дочерние компоненты через входные параметры, но как организовать обратную коммуникацию, когда что-то случится? Самое время поговорить о системе пользовательских событий Vue.

### Использование `v-on` с Пользовательскими Событиями

Каждый инстанс Vue поддерживает [интерфейс Событий](../api/#Instance-Methods-Events), что означает возможность:

- Слушать события, используя `$on(eventName)`
- Порождать события, используя `$emit(eventName)`

<p class="tip">Обратите внимание, что система событий Vue отделена от [EventTarget API](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget). Хотя они и похожи, `$on` и `$emit` __не являются__ псевдонимами для `addEventListener` и `dispatchEvent`.</p>

Кроме того, родительский компонент может зарегистрировать слушателя событий, используя директиву `v-on` непосредственно в шаблоне при создании дочернего компонента.

Вот пример:

``` html
<div id="counter-event-example">
  <p>{{ total }}</p>
  <button-counter v-on:increment="incrementTotal"></button-counter>
  <button-counter v-on:increment="incrementTotal"></button-counter>
</div>
```

``` js
Vue.component('button-counter', {
  template: '<button v-on:click="increment">{{ counter }}</button>',
  data: function () {
    return {
      counter: 0
    }
  },
  methods: {
    increment: function () {
      this.counter += 1
      this.$emit('increment')
    }
  },
})

new Vue({
  el: '#counter-event-example',
  data: {
    total: 0
  },
  methods: {
    incrementTotal: function () {
      this.total += 1
    }
  }
})
```

{% raw %}
<div id="counter-event-example" class="demo">
  <p>{{ total }}</p>
  <button-counter v-on:increment="incrementTotal"></button-counter>
  <button-counter v-on:increment="incrementTotal"></button-counter>
</div>
<script>
Vue.component('button-counter', {
  template: '<button v-on:click="increment">{{ counter }}</button>',
  data: function () {
    return {
      counter: 0
    }
  },
  methods: {
    increment: function () {
      this.counter += 1
      this.$emit('increment')
    }
  },
})
new Vue({
  el: '#counter-event-example',
  data: {
    total: 0
  },
  methods: {
    incrementTotal: function () {
      this.total += 1
    }
  }
})
</script>
{% endraw %}

В этом примере важно заметить, что дочерний компонент всё ещё полностью независим от всего происходящего снаружи. Он всего лишь уведомляет внешний мир о происходящем с ним, на случай если родительскому компоненту это может быть интересно.

#### Слушание Нативных Событий в Компонентах

Иногда может понадобиться слушать нативные события на корневом элементе компонента. В таких случаях можно применить `v-on` с модификатором `.native`, например так:

``` html
<my-component v-on:click.native="doTheThing"></my-component>
```

### Элементы Ввода Форм и Пользовательские События

Пользуясь этой стратегией можно также создавать пользовательские элементы ввода форм, работающие с `v-model`. Вспомните, что

``` html
<input v-model="something">
```

это всего лишь синтаксический сахар для:

``` html
<input v-bind:value="something" v-on:input="something = $event.target.value">
```

При использовании с компонентом, запись упрощается до:

``` html
<input v-bind:value="something" v-on:input="something = arguments[0]">
```

Таким образом, чтобы иметь возможность работать с `v-model`, компонент должен:

- принимать входной параметр `value`
- эмитировать событие `input` с новым значением

Давайте разберём в качестве примера простой элемент ввода цены в валюте:

``` html
<currency-input v-model="price"></currency-input>
```

``` js
Vue.component('currency-input', {
  template: '\
    <span>\
      $\
      <input\
        ref="input"\
        v-bind:value="value"\
        v-on:input="updateValue($event.target.value)"\
      >\
    </span>\
  ',
  props: ['value'],
  methods: {
    // Этот метод используется для форматирования и
    // нормализации введённого значения, а также порождает
    // событие, уведомляющее родительский компонент об изменениях
    updateValue: function (value) {
      var formattedValue = value
        // Удалить пробелы с обеих сторон
        .trim()
        // Shorten to 2 decimal places
        .slice(0, value.indexOf('.') + 3)
      // Если значение не нормализовано — нормализуем вручную
      if (formattedValue !== value) {
        this.$refs.input.value = formattedValue
      }
      // Порождаем событие с обновлённым значением элемента ввода
      this.$emit('input', Number(formattedValue))
    }
  }
})
```

{% raw %}
<div id="currency-input-example" class="demo">
  <currency-input v-model="price"></currency-input>
</div>
<script>
Vue.component('currency-input', {
  template: '\
    <span>\
      $\
      <input\
        ref="input"\
        v-bind:value="value"\
        v-on:input="updateValue($event.target.value)"\
      >\
    </span>\
  ',
  props: ['value'],
  methods: {
    updateValue: function (value) {
      var formattedValue = value
        .trim()
        .slice(0, value.indexOf('.') + 3)
      if (formattedValue !== value) {
        this.$refs.input.value = formattedValue
      }
      this.$emit('input', Number(formattedValue))
    }
  }
})
new Vue({ el: '#currency-input-example' })
</script>
{% endraw %}

Реализация выше, конечно, остаётся довольно наивной. Например, она позволяет пользователям вводить несколько десятичных точек, и даже иногда буквы - упс! Если вы хотите более сложный и надёжный пример, то вот он:

<iframe width="100%" height="300" src="https://jsfiddle.net/chrisvfritz/1oqjojjx/embedded/result,html,js" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

Кроме того, этот интерфейс может быть использован не только для связи с элементами ввода форм внутри компонентов, но и для интеграции новоизобретённых типов. Представьте только такие возможности:

``` html
<voice-recognizer v-model="question"></voice-recognizer>
<webcam-gesture-reader v-model="gesture"></webcam-gesture-reader>
<webcam-retinal-scanner v-model="retinalImage"></webcam-retinal-scanner>
```

### Коммуникация вне случаев Родитель-Ребёнок

Иногда компонантам необходимо обмениваться информацией, хотя они и не являются родителями/детьми друг другу. В простых случаях может быть достаточным использование пустого инстанса Vue как центральной шины данных:

``` js
var bus = new Vue()
```
``` js
// в методе компонента A
bus.$emit('id-selected', 1)
```
``` js
// в хуке created компонента B
bus.$on('id-selected', function (id) {
  // ...
})
```

Для более сложных случаев, стоит рассмотреть использование специального [шаблона управления состоянием](state-management.html).

## Дистрибьюция Контента через Слоты

Нередко хочется вкладывать компоненты друг в друга подобным образом:

``` html
<app>
  <app-header></app-header>
  <app-footer></app-footer>
</app>
```

Здесь стоит обратить внимание на две вещи:

1. The `<app>` component does not know what content may be present inside its mount target. It is decided by whatever parent component that is using `<app>`.
1. Компонент `<app>` не знает, какой контент будет содержать после монтирования. Решение принимается родителем, использующим `<app>`.

2. Скорее всего у компонента `<app>` есть собственный шаблон.

Чтобы такая композиция работала, необходим метод переплетения родительского "содержимого" и собственного шаблона компонента. Этот процесс называется **дистрибьюцией контента** (или, в терминах Angular — "включением"("transclusion")). Vue.js содержит API дистрибьюции контента, смоделированное в соответствии с текущим [черновиком спецификации Web Components](https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md) и использующее специальные элементы `<slot>`, служащие "точками выхода" для оригинального контента.

### Компиляционная Область Видимости

Перед тем как углубиться в рассмотрение API, давайте разберёмся, в какой области видимости компилируется содержимое. Представим такой шаблон:

``` html
<child-component>
  {{ message }}
</child-component>
```

Из родительского или из дочернего контекста должна быть взята переменная `message`? Правильный ответ — из родительского. Простое правило таково:

> Всё в шаблоне родителя компилируется в области видимости родителя; всё в шаблоне дочернего компонента — в его области видимости.

Распространённой ошибкой является попытка связи со свойством дочернего компонента в родительском шаблоне: 

``` html
<!-- НЕ сработает -->
<child-component v-show="someChildProperty"></child-component>
```

Если `someChildProperty` является свойством дочернего компонента, вышеприведённый пример не будет работать. Шаблон родительского компонента не имеет никакого представления о состоянии дочернего компонента.

При необходимости привязать директивы из области видимости дочернего компонента к корневому элементу, это необходимо сделать в его же шаблоне:

``` js
Vue.component('child-component', {
  // это — сработает, так как мы находимся в правильной области видимости
  template: '<div v-show="someChildProperty">Child</div>',
  data: function () {
    return {
      someChildProperty: true
    }
  }
})
```

Аналогично, дистрибутируемый контент будет также компилироваться в родительской области видимости.

### Вариант с Единственным Слотом

Родительский контент будет **отброшен**, если в шаблоне дочернего компонента не будет содержаться хотя бы один `<slot>`. В случае, если слот всего один, и не содержит аттрибутов, всё содержимое родительского элемента будет помещено в этой позиции в DOM, замещая собой сам слот.

Всё изначальное содержимое тега `<slot>` считается **резервным контентом**. Оно компилируется в области видимости дочернего элемента и отображается только в случае, если родительский элемент пуст.

Предположим, у нас есть компонент под названием `my-component`, с нижеуказанным шаблоном:

``` html
<div>
  <h2>Я — заголовок дочернего компонента</h2>
  <slot>
    Этот текст будет отображён только если
    не будет передано контента для дистрибьюции.
  </slot>
</div>
```

И родитель, использующий этот компонент:

``` html
<div>
  <h1>Я — заголовок родителя</h1>
  <my-component>
    <p>Немного оригинального контента</p>
    <p>И ещё немного</p>
  </my-component>
</div>
```

Результатом рендеринга будет:

``` html
<div>
  <h1>Я — заголовок родителя</h1>
  <div>
    <h2>Я — заголовок дочернего компонента</h2>
    <p>Немного оригинального контента</p>
    <p>И ещё немного</p>
  </div>
</div>
```

### Именованные Слоты

Для элементов `<slot>` можно указать специальный аттрибут, `name`, который используется для ещё более точных указаний по дистрибьюции контента. Можно создать несколько слотов с разничными именами. Именованный слот получит весь контент, помеченный соответствующим значением аттрибута `slot`.

Один из слотов можно оставить безымянным, что сделает его **слотом по умолчанию**, в который попадёт весь контент, для которого имя слота не указано. В случае отсутствия безымянного слота, такой контент будет попросту отброшен.

Например, предположим у на есть компонент `app-layout` с нижеследующим шаблоном:

``` html
<div class="container">
  <header>
    <slot name="header"></slot>
  </header>
  <main>
    <slot></slot>
  </main>
  <footer>
    <slot name="footer"></slot>
  </footer>
</div>
```

Шаблон родителя:

``` html
<app-layout>
  <h1 slot="header">Здесь мог бы быть заголовок страницы</h1>

  <p>Абзац основного контента.</p>
  <p>И ещё один.</p>

  <p slot="footer">Здесь — контактная информация</p>
</app-layout>
```

Результатом рендеринга будет:

``` html
<div class="container">
  <header>
    <h1>Здесь мог бы быть заголовок страницы</h1>
  </header>
  <main>
    <p>Абзац основного контента.</p>
    <p>И ещё один.</p>
  </main>
  <footer>
    <p>Здесь — контактная информация</p>
  </footer>
</div>
```

API дистрибьюции контента оказывается очень полезный механизм при создании компонентов, которые задуманы чтобы работать вместе.

## Динамические Компоненты

You can use the same mount point and dynamically switch between multiple components using the reserved `<component>` element and dynamically bind to its `is` attribute:
Существует возможность динамического переключения между различными компонентами, имеющими одну и ту же точку монтирования. Для этого используется псевдоэлемент `<component>` и динамическое связывание его аттрибута `is`:


``` js
var vm = new Vue({
  el: '#example',
  data: {
    currentView: 'home'
  },
  components: {
    home: { /* ... */ },
    posts: { /* ... */ },
    archive: { /* ... */ }
  }
})
```

``` html
<component v-bind:is="currentView">
  <!-- изменения vm.currentView поменяют отображаемый компонент! -->
</component>
```

При желании можно связываться с объектами компонентов и напрямую:

``` js
var Home = {
  template: '<p>Welcome home!</p>'
}

var vm = new Vue({
  el: '#example',
  data: {
    currentView: Home
  }
})
```

### `keep-alive`

Если вы хотите сохранять временно выключенные компоненты в памяти для сохранения их состояния и избегания повторного рендеринга, можно завернуть динамический компонент в псевдоэлемент `<keep-alive>`:

``` html
<keep-alive>
  <component :is="currentView">
    <!-- inactive components will be cached! -->
  </component>
</keep-alive>
```

Более детально `<keep-alive>` рассмотрен в [справочнике по API](../api/#keep-alive).

## Разное

### Создание Повторно Используемых Компонентов

Создавая компоненты, неплохо понимать, собираетесь ли вы использовать их где-то ещё впоследствии. Хотя для одноразовых компонентов нормально быть сильно связанными, но повторно используемым обязательно необходим ясный публичный интерфейс, не делающий изличных предположений о контексте, в котором компонент будет использоваться.

API компонентов Vue состоит из трёх частей: входных параметров, событий и слотов:

- **Входные параметры** позволяют передавать в компонент данные извне.

- **События** позволяют компонентам инициировать побочные эффекты во внешнем окружении.

- **Слоты** позволяют композицию компонентов и дополнительного контента.

С использованием специального сокращённого синтаксиса `v-bind` и `v-on`, намерения можно ясно выразить в шаблоне:

``` html
<my-component
  :foo="baz"
  :bar="qux"
  @event-a="doThis"
  @event-b="doThat"
>
  <img slot="icon" src="...">
  <p slot="main-text">Hello!</p>
</my-component>
```

### Ссылки на Дочерние Компоненты

Несмотря на наличие входных параметров и событий, иногда всё же возникает необходимость обратиться к дочерним компонентам в JavaScript напрямую. Для этих целей можно сохранить ссылку на дочерний компонент при помощи аттрибута `ref`. Например:

``` html
<div id="parent">
  <user-profile ref="profile"></user-profile>
</div>
```

``` js
var parent = new Vue({ el: '#parent' })
// получаем инстанс дочернего компонента
var child = parent.$refs.profile
```

Если `ref` используется вместе с директивой `v-for`, создаётся массив или объект со ссылками на инстансы, структурно повторяющий исходные данные.

<p class="tip">Объект `$refs` заполняется уже после рендеринга компонента, и не является реактивным. Использования `$refs` в шаблонах и вычисляемых свойствах следует избегать, рассматривая его только как последнюю резервную возможность.</p>

### Асинхронные Компоненты

В крупных приложениях может возникнуть необходимость в разделении приложения на меньшие части с целями отложенной загрузки. Для облегчения таких сценариев, Vue позволяет определить компонент как функцию-фабрику, асинхронно возвращающую определение компонента. Vue вызовет фабричную функцию только тогда, когда компонент действительно понадобится, и закеширует результат для дальнейшего использования. Например:

``` js
Vue.component('async-example', function (resolve, reject) {
  setTimeout(function () {
    resolve({
      template: '<div>Я — асинхронный!</div>'
    })
  }, 1000)
})
```

Функция-фабрика получает параметр `resolve` — функцию обратного вызова, которую следует вызывать после получения компонента от сервера. Кроме того, можно вызвать `reject(reason)`, если загрузка по какой-либо причине не удалась. Мы используем `setTimeout` исключительно в демонстрационных целях; Как именно получать компонент — решать только вам самим. Одним из рекомендованных подходов будет использование асинхроннх компонент в связке с [возможностями Webpack's по разделению кода](http://webpack.github.io/docs/code-splitting.html):

``` js
Vue.component('async-webpack-example', function (resolve) {  
  // Специальный синтаксис require укажет Webpack
  // автоматически разделить сборку на части
  // для последующей асинхронной загрузки
  require(['./my-async-component'], resolve)
})
```

В функции resolve можно также вернуть `Promise`, так что используя Webpack 2 и синтаксиса ES2015 можно сделать так:

``` js
Vue.component(
  'async-webpack-example',
  () => System.import('./my-async-component')
)
```

<p class="tip">Если вы являетесь пользователем <strong>Browserify</strong> и хотите также использовать асинхронные компоненты, нам к сожалению придётся вас огорчить: это невозможно, и в ряд ли будет возможно когда-либо, така как сам создатель Browserify [пояснил](https://github.com/substack/node-browserify/issues/58#issuecomment-21978224) что асинхронная загрузка "не является чем-то, что Browserify когда-либо будет поддерживать." Если упомянутая возможность важна для вас, мы советуем использовать Webpack.</p>

### Соглашения по Именованию Компонентов

При регистрации компонентов (или входных параметров), вы можете использовать kebab-case, camelCase, или TitleCase. Vue — без разницы.

``` js
// при определении компонента
components: {
  // регистрация с использованием camelCase
  'kebab-cased-component': { /* ... */ },
  'camelCasedComponent': { /* ... */ },
  'TitleCasedComponent': { /* ... */ }
}
```

В HTML-шаблонах, однако, придётся использовать эквивалентный kebab-case:

``` html
<!-- всегда используйте kebab-case в HTML-шаблонах -->
<kebab-cased-component></kebab-cased-component>
<camel-cased-component></camel-cased-component>
<title-cased-component></title-cased-component>
```

Однако, при использовании _строковых_ шаблонов, мы уже не связаны ограничениями регистронезависимости HTML. Это значит, что даже в шаблоне, вы можете указывать компоненты и входные параметры как в camelCase, так и в PascalCase или kebab-case:

``` html
<!-- в строковых шаблонах вы вольны использовать любой подход! -->
<my-component></my-component>
<myComponent></myComponent>
<MyComponent></MyComponent>
```

Если компонент не содержит слотов, его можно даже сделать самозакрывающимся, указав `/` после имени:

``` html
<my-component/>
```

Ещё раз заметим, что это возможно _только_ при использовании строковых шаблонов, поскольку самозакрывающие пользовательские элементы не являются валидными в HTML, и нативные парсеры браузеров такую запись не поймут.

### Рекурсивные Компоненты

Компоненты могут рекурсивно вызывать самих себя в своих шаблонах. Однако, эта возможность доступна только при указании опции `name`:

``` js
name: 'unique-name-of-my-component'
```

When you register a component globally using `Vue.component`, the global ID is automatically set as the component's `name` option.

``` js
Vue.component('unique-name-of-my-component', {
  // ...
})
```

If you're not careful, recursive components can also lead to infinite loops:

``` js
name: 'stack-overflow',
template: '<div><stack-overflow></stack-overflow></div>'
```

Компонент, подобный вышеописанному, породит ошибку переполнения стека, поэтому обязательно удостоверьтесь, что рекурсивный вызов является условным (т.е. использует директиву `v-if`, которая рано или поздно станет ложной).

### Inline-Шаблоны

При указании специального аттрибута `inline-template` для дочернего компонента, внутренности элемента будут использованы не для дистрибьюции контента, а в качестве шаблона дочернего компонента. Это делает разработку компонентов более гибкой.

``` html
<my-component inline-template>
  <div>
    <p>Этот шаблон будет скомпилирован в области видимости дочернего компонента.</p>
    <p>Доступа к данным родителя — нет.</p>
  </div>  
</my-component>
```

Однако, использование `inline-template` затрудняет понимание происходящего в шаблонах. На правах best practice, определение шаблонов внутри компонента с использованием опции `template` или в элементе `template` `.vue`-файла является более предпочтительным.

### Определение Шаблонов через X-Template

Другой возможностью определения шаблонов является использование специальных элементов `script` с указанием типа `text/x-template` и id, на который можно сослаться при регистрации шаблона. Например:

``` html
<script type="text/x-template" id="hello-world-template">
  <p>Hello hello hello</p>
</script>
```

``` js
Vue.component('hello-world', {
  template: '#hello-world-template'
})
```

Эта возможность может оказаться полезной для демо с большими шаблонами, или в очень маленьких приложениях, но в целом в силу разделения шаблонов с остальными частями определения компонентов, этого подхода следует избегать.

### Дешёвые Статические Компоненты с использованием `v-once`

Рендеринг простых элементов HTML во Vue происходит очень быстро, но иногда возникают компоненты с **большим** количеством статических данных. В таких случаях добавление директивы `v-once` в корневом элементе позволяет удостовериться, что все вычисления будут произведены лишь однажды, а дальше работа будет происходить с кэшем, например таким образом:

``` js
Vue.component('terms-of-service', {
  template: '\
    <div v-once>\
      <h1>Условия Использования</h1>\
      ... много-много статического контента ...\
    </div>\
  '
})
```
