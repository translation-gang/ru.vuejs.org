---
title: API
type: api
---

## Глобальные параметры

`Vue.config` — это объект, содержащий глобальные параметры Vue. Перед загрузкой приложения можно изменить следующие свойства:

### silent

- **Тип:** `boolean`

- **По умолчанию:** `false`

- **Использование:**

  ``` js
  Vue.config.silent = true
  ```

  Отключает вывод логов и предупреждений Vue.

### optionMergeStrategies

- **Тип:** `{ [key: string]: Function }`

- **По умолчанию:** `{}`

- **Использование:**

  ``` js
  Vue.config.optionMergeStrategies._my_option = function (parent, child, vm) {
    return child + 1
  }

  const Profile = Vue.extend({
    _my_option: 1
  })

  // Profile.options._my_option = 2
  ```

  Меняет стратегию слияния опций на вашу собственную.

  Стратегия слияния получает значения опции родительского и дочернего элемента первым и вторым параметром соответственно.
  Третьим параметром передаётся контекст действующего экземпляра Vue.

- **См. также:** [Пользовательские стратегии слияния опций](../guide/mixins.html#Пользовательские-стратегии-слияния-опций)

### devtools

- **Тип:** `boolean`

- **По умолчанию:** `true` (`false` в production-сборках)

- **Использование:**

  ``` js
  // убедитесь, что устанавливаете это свойство синхронно сразу после загрузки Vue
  Vue.config.devtools = true
  ```

  Указывает, должен ли Vue позволять [Vue-devtools](https://github.com/vuejs/vue-devtools) проводить инспекцию. Значение по умолчанию для development-окружения — `true`, для production-сборок — `false`. Установите `true`, чтобы vue-devtools работал и в production.

### errorHandler

- **Тип:** `Function`

- **По умолчанию:** `undefined`

- **Использование:**

  ``` js
  Vue.config.errorHandler = function (err, vm, info) {
    // обработка ошибки
    // `info` это информация Vue-специфичной ошибки, например в каком хуке жизненного цикла
    // была найдена ошибка. Доступно только в версиях 2.2.0+
  }
  ```

  Устанавливает обработчик для ошибок, не пойманных во время рендеринга компонентов и в наблюдателях. Обработчик получит в параметрах ошибку и действующий экземпляр Vue.

  > В версии 2.2.0+, этот хук также отслеживает ошибки в хуках жизненного цикла компонентов. Кроме того, при установленном значении `undefined` захваченные ошибки будут зарегистрированы с помощью `console.error` вместо вызова сбоя приложения.

  > В версии 2.4.0+, этот хук также отслеживает ошибки, возникающие внутри пользовательских обработчиков событий Vue.

  > Сервисы отслеживания ошибок [Sentry](https://sentry.io/for/vue/) и [Bugsnag](https://docs.bugsnag.com/platforms/browsers/vue/) предлагают официальную интеграцию с использованием этого свойства.

### warnHandler

> Добавлено в версии 2.4.0+

- **Тип:** `Function`

- **По умолчанию:** `undefined`

- **Использование:**

  ``` js
  Vue.config.warnHandler = function (msg, vm, trace) {
    // `trace` — это трассировка иерархии компонентов
  }
  ```

  Назначает пользовательский обработчик предупреждений Vue во время выполнения. Обратите внимание, что это работает только в версии для разработки и игнорируется в версии для production.

### ignoredElements

- **Тип:** `Array<string | RegExp>`

- **По умолчанию:** `[]`

- **Использование:**

  ``` js
  Vue.config.ignoredElements = [
    'my-custom-web-component',
    'another-web-component',
    // Используйте `RegExp` чтобы игнорировать все элементы, начинающиеся с "ion-"
    // Добавлено в версии 2.5.0+
    /^ion-/
  ]
  ```

  Позволяет Vue игнорировать пользовательские компоненты, установленные за пределами Vue (например, используя Web Components API). Иначе возникнет предупреждение о "Неизвестном пользовательском элементе", означающее, что вы забыли зарегистрировать глобальный компонент или допустили ошибку в написании имени компонента.

### keyCodes

- **Тип:** `{ [key: string]: number | Array<number> }`

- **По умолчанию:** `{}`

- **Использование:**

  ``` js
  Vue.config.keyCodes = {
    v: 86,
    f1: 112,
    // camelCase не будет работать
    mediaPlayPause: 179,
    // можно использовать kebab-case в двойных кавычках
   "media-play-pause": 179,
    up: [38, 87]
  }
  ```

  ```js
  <input type="text" @keyup.media-play-pause="method">
  ```

  Определение пользовательских псевдонимов для директивы `v-on`.

### performance

> Добавлено в версии 2.2.0+

- **Тип:** `boolean`

- **По умолчанию:** `false` (с версии 2.2.3+)

- **Использование:**

  Установите в `true`, чтобы включить отслеживание производительности на этапах инициализации, компиляции, рендера и обновления компонента на графике в инструментах разработчика браузера. Работает только в режиме разработки и в браузерах, которые поддерживают [performance.mark](https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark) API.

### productionTip

> Добавлено в версии 2.2.0+

- **Тип:** `boolean`

- **По умолчанию:** `true`

- **Использование:**

  Установите в `false`, чтобы отключить предупреждение о работе в режиме разработки при запуске Vue.

## Глобальный API

### Vue.extend( options )

- **Аргументы:**
  - `{Object} options`

- **Использование:**

  Создаёт "подкласс" базового конструктора Vue. Принимает параметром объект с опциями нового компонента.

  Внимание: у объекта, переданного в `Vue.extend()` свойство `data` должно быть функцией.

  ``` html
  <div id="mount-point"></div>
  ```

  ``` js
  // Создание конструктора
  var Profile = Vue.extend({
    template: '<p>{{firstName}} {{lastName}}, также известный как {{alias}}</p>',
    data: function () {
      return {
        firstName: 'Уолтер',
        lastName: 'Уайт',
        alias: 'Гейзенберг'
      }
    }
  })
  // создаёт экземпляр Profile и монтирует его к элементу DOM
  new Profile().$mount('#mount-point')
  ```

  Результатом будет:

  ``` html
  <p>Уолтер Уайт, также известный как Гейзенберг</p>
  ```

- **См. также:** [Компоненты](../guide/components.html)

### Vue.nextTick( [callback, context] )

- **Аргументы:**
  - `{Function} [callback]`
  - `{Object} [context]`

- **Использование:**

  Выполняет функцию `callback` при следующем цикле обновления DOM. Вызывайте сразу после изменения данных, чтобы работать с обновлённым DOM.

  ``` js
  // изменение данных
  vm.msg = 'Привет'
  // DOM ещё не обновлён
  Vue.nextTick(function () {
    // теперь DOM обновлён
  })

  // использование с Promise (добавлено в 2.1.0+, см. примечание ниже)
  Vue.nextTick()
    .then(function () {
      // DOM обновлён
    })
  ```

  > Добавлено в версии 2.1.0+: возвращает `Promise`, если окружение их поддерживает и коллбэк не указан. Обратите внимание, что Vue не поставляется с полифиллом для `Promise`. Поэтому при необходимости поддержки браузеров, которые не поддерживают их нативно (например, IE), вам придётся предоставить полифилл самостоятельно.

- **См. также:** [Асинхронная очередь обновлений](../guide/reactivity.html#Асинхронная-очередь-обновлений)

### Vue.set( target, key, value )

- **Аргументы:**
  - `{Object | Array} target`
  - `{string | number} key`
  - `{any} value`

- **Возвращает:** установленное значение.

- **Использование:**

  Меняет значение поля. Если объект реактивный, поле тоже станет реактивным, а шаблон обновится. Обычно нужен, потому что Vue не может среагировать на неявное добавление полей.

  <p class="tip">Обратите внимание что объект не может быть экземпляром Vue или корневым объектом data экземпляра Vue.</p>

- **См. также:** [Подробно о реактивности](../guide/reactivity.html)

### Vue.delete( target, key )

- **Аргументы:**
  - `{Object| Array} target`
  - `{string | number} key/index`

  > Только в версиях 2.2.0+: Также работает с массивами + индексами.

- **Использование:**

  Удаляет поле. Если объект реактивный, шаблон обновится. Обычно нужен, потому что Vue не может среагировать на неявное удаление полей (но вам редко когда это понадобится).

  <p class="tip">Объект `target` не может быть экземпляром Vue, или корневым объектом данных экземпляра Vue.</p>

- **См. также:** [Подробно о реактивности](../guide/reactivity.html)

### Vue.directive( id, [definition] )

- **Аргументы:**
  - `{string} id`
  - `{Function | Object} [definition]`

- **Использование:**

  Регистрирует новую глобальную директиву или возвращает уже зарегистрированную.

  ``` js
  // регистрируем директиву-объект:
  Vue.directive('my-directive', {
    bind: function () {},
    inserted: function () {},
    update: function () {},
    componentUpdated: function () {},
    unbind: function () {}
  })

  // регистрируем директиву в виде простой функции:
  Vue.directive('my-directive', function () {
    // Vue будет вызывать эту функцию как `bind` и `update`
  })

  // получаем определение директивы, если она зарегистрирована:
  var myDirective = Vue.directive('my-directive')
  ```

- **См. также:** [Пользовательские директивы](../guide/custom-directive.html)

### Vue.filter( id, [definition] )

- **Аргументы:**
  - `{string} id`
  - `{Function} [definition]`

- **Использование:**

  Регистрирует новый глобальный фильтр или возвращает уже зарегистрированный.

  ``` js
  // регистрируем фильтр:
  Vue.filter('my-filter', function (value) {
    // возвращаем обработанное значение
  })

  // получаем фильтр, если он зарегистрирован:
  var myFilter = Vue.filter('my-filter')
  ```

  **См. также:** [Фильтры](../guide/filters.html)

### Vue.component( id, [definition] )

- **Аргументы:**
  - `{string} id`
  - `{Function | Object} [definition]`

- **Использование:**

  Регистрирует новый глобальный компонент или возвращает уже зарегистрированный. Регистрация также автоматически установит свойство `name` компонента равным переданному `id`.

  ``` js
  // регистрируем конструктор, полученный из `Vue.extend`:
  Vue.component('my-component', Vue.extend({ /* ... */ }))

  // регистрируем объект с опциями (Vue вызовет для этого объекта `Vue.extend` автоматически):
  Vue.component('my-component', { /* ... */ })

  // получаем зарегистрированный компонент (всегда вернёт конструктор):
  var MyComponent = Vue.component('my-component')
  ```

- **См. также:** [Компоненты](../guide/components.html)

### Vue.use( plugin )

- **Аргументы:**
  - `{Object | Function} plugin`

- **Использование:**

  Устанавливает плагин Vue.js. Если плагин — объект, у него должен быть публичный метод `install`. Если плагин — функция, она будет воспринята как метод `install`. Этот метод будет выполнен с Vue в качестве аргумента.

  Плагин будет установлен только один раз, независимо от количества вызовов этого метода с одним и тем же плагином.

- **См. также:** [Плагины](../guide/plugins.html)

### Vue.mixin( mixin )

- **Аргументы:**
  - `{Object} mixin`

- **Использование:**

  Применяет примесь ко всем созданным впоследствии экземплярам Vue. Так авторы плагинов могут встроить желаемое поведение в компоненты. **Не рекомендуется использовать в коде приложений**.

- **См. также:** [Глобальные примеси](../guide/mixins.html#Глобальные-примеси)

### Vue.compile( template )

- **Аргументы:**
  - `{string} template`

- **Использование:**

  Компилирует строковый шаблон в `render`-функцию. **Доступно только в полной сборке.**

  ``` js
  var res = Vue.compile('<div><span>{{ msg }}</span></div>')

  new Vue({
    data: {
      msg: 'hello'
    },
    render: res.render,
    staticRenderFns: res.staticRenderFns
  })
  ```

- **См. также:** [Render-функции и JSX](../guide/render-function.html)

### Vue.version

- **Подробности:** Возвращает версию используемого Vue в виде строки. Это может быть полезно при разработке плагинов и компонентов, где вы могли бы использовать различные стратегии для работы с разными версиями.

- **Использование:**

  ```js
  var version = Number(Vue.version.split('.')[0])

  if (version === 2) {
    // Vue v2.x.x
  } else if (version === 1) {
    // Vue v1.x.x
  } else {
    // Неподдерживамые версии Vue
  }
  ```

## Опции — данные

### data

- **Тип:** `Object | Function`

- **Ограничение:** При создании компонента, может быть только типа `Function`.

- **Подробности:**

  Объект с данными экземпляра Vue. Vue рекурсивно переводит его поля в геттеры/сеттеры, и он становится "реактивным". **Объект должен быть простым**: Vue проигнорирует свойства прототипа и нативные объекты, как например из API браузера. Прежде всего, рекомендуем, чтобы данные были просто данными — не стоит передавать сюда объекты с собственным управлением внутренним состоянием.

  Добавлять реактивные свойства к корневому объекту данных после его инициализации нельзя. Поэтому определяйте корневые реактивные свойства до создания экземпляра.

  После создания экземпляра, объект с данными доступен в `vm.$data`. Кроме того, экземпляр Vue проксирует обнаруженные в нём свойства, так что `vm.a` эквивалентно `vm.$data.a`.

  Свойства, названия которых начинается с `_` или `$` **не проксируются** из-за возможных конфликтов со внутренними свойствами и методами API Vue. Доступ к таким свойствам возможен только через `vm.$data._property`.

  Для определения **компонента** опция `data` должна быть функцией, возвращающей объект для инициализации, потому что из одного определения компонента может быть создано несколько экземпляров. Если бы мы использовали для `data` простой объект, все созданные экземпляры получили бы **ссылку на него**! А когда `data` — функция, при создании нового экземпляра можно вызвать её и получить свежую копию данных для инициализации.

  Чтобы получить полную копию оригинального объекта, передайте `vm.$data` в `JSON.parse(JSON.stringify(...))`.

- **Пример:**

  ``` js
  var data = { a: 1 }

  // создаём экземпляр напрямую:
  var vm = new Vue({
    data: data
  })
  vm.a // => 1
  vm.$data === data // => true

  // обязательно используйте функцию во `Vue.extend()`:
  var Component = Vue.extend({
    data: function () {
      return { a: 1 }
    }
  })
  ```

  <p class="tip">Обратите внимание, что __вам не стоит использовать стрелочные функции в параметре `data`__ (напр. `data: () => { return { a: this.myProp }}`). Поскольку стрелочные функции связываются с родительским контекстом, `this` не будет указывать на экземпляр Vue и `this.myProp` окажется неопределённым.</p>

- **См. также:** [Подробно о реактивности](../guide/reactivity.html)

### props

- **Тип:** `Array<string> | Object`

- **Подробности:**

  Список или хэш атрибутов, по которым разрешено получение данных от родительского компонента. Передайте простой массив названий или объект, задающий дополнительные параметры, например типы, правила валидации и значения по умолчанию.

- **Пример:**

  ``` js
  // простая форма записи:
  Vue.component('props-demo-simple', {
    props: ['size', 'myMessage']
  })

  // объект с указанием правил валидации:
  Vue.component('props-demo-advanced', {
    props: {
      // только проверка типа
      height: Number,
      // проверка типа и другие правила валидации
      age: {
        type: Number,
        default: 0,
        required: true,
        validator: function (value) {
          return value >= 0
        }
      }
    }
  })
  ```

- **См. также:** [Входные параметры](../guide/components.html#Входные-параметры)

### propsData

- **Тип:** `{ [key: string]: any }`

- **Ограничение:** учитывается только при создании экземпляра выражением `new`.

- **Подробности:**

  Параметры компонента при его создании. Обычно используются для облегчения модульного тестирования.

- **Пример:**

  ``` js
  var Comp = Vue.extend({
    props: ['msg'],
    template: '<div>{{ msg }}</div>'
  })

  var vm = new Comp({
    propsData: {
      msg: 'привет'
    }
  })
  ```

### computed

- **Тип:** `{ [key: string]: Function | { get: Function, set: Function } }`

- **Подробности:**

  Вычисляемые свойства, которые будут подмешаны к экземпляру Vue. В геттерах и сеттерах `this` будет указывать на экземпляр Vue.

  <p class="tip">Обратите внимание, что __вам не стоит использовать стрелочные функции при определении вычисляемых свойств__ (напр. `aDouble: () => this.a * 2`). Поскольку стрелочные функции связываются с родительским контекстом, `this` не будет указывать на экземпляр Vue, и `this.a` окажется неопределённым.</p>

  Вычисляемые свойства кешируются и повторно вычисляются только при изменении реактивных зависимостей. Обратите внимание, что если определённая зависимость выходит за область видимости экземпляра (т.е не реактивная), то вычисляемое свойство **не будет** обновляться.

- **Пример:**

  ```js
  var vm = new Vue({
    data: { a: 1 },
    computed: {
      // если свойство только возвращает данные, достаточно простой функции:
      aDouble: function () {
        return this.a * 2
      },
      // свойство и возвращает, и получает данные:
      aPlus: {
        get: function () {
          return this.a + 1
        },
        set: function (v) {
          this.a = v - 1
        }
      }
    }
  })
  vm.aPlus   // => 2
  vm.aPlus = 3
  vm.a       // => 2
  vm.aDouble // => 4
  ```

- **См. также:** [Вычисляемые свойства](../guide/computed.html)

### methods

- **Тип:** `{ [key: string]: Function }`

- **Подробности:**

  Методы, которые будут подмешаны к экземпляру Vue. Вы можете запустить эти методы прямо из экземпляра VM, или использовать их в директивах. `this` методов указывает на экземпляр Vue.

  <p class="tip">Обратите внимание, что __вам не стоит использовать стрелочные функции при определении методов__ (напр. `plus: () => this.a++`). Поскольку стрелочные функции связываются с родительским контекстом, `this` не будет указывать на экземпляр Vue, и `this.a` окажется неопределённым.</p>

- **Пример:**

  ```js
  var vm = new Vue({
    data: { a: 1 },
    methods: {
      plus: function () {
        this.a++
      }
    }
  })
  vm.plus()
  vm.a // 2
  ```

- **См. также:** [Обработка событий](../guide/events.html)

### watch

- **Тип:** `{ [key: string]: string | Function | Object | Array }`

- **Подробности:**

  Объект, ключи которого — выражения для наблюдения, а значения — коллбэки, вызываемые при их изменении. Значения также могут быть строками с именами методов, или объектами, содержащими дополнительные опции. Экземпляр Vue вызовет `$watch()` соответствующий каждому ключу объекта при своём создании.

- **Пример:**

  ``` js
  var vm = new Vue({
    data: {
      a: 1,
      b: 2,
      c: 3,
      d: 4,
      e: {
        f: {
          g: 5
        }
      }
    },
    watch: {
      a: function (val, oldVal) {
        console.log('новое значение: %s, старое значение: %s', val, oldVal)
      },
      // строка с именем метода:
      b: 'someMethod',
      // глубокий (рекурсивный) наблюдатель:
      c: {
        handler: function (val, oldVal) { /* ... */ },
        deep: true
      },
      // коллбэк будет вызван сразу же после начала наблюдения
      d: {
        handler: function (val, oldVal) { /* ... */ },
        immediate: true
      },
      e: [
        function handle1 (val, oldVal) { /* ... */ },
        function handle2 (val, oldVal) { /* ... */ }
      ],
      // отслеживание значения `vm.e.f`: {g: 5}
      'e.f': function (val, oldVal) { /* ... */ }
    }
  })
  vm.a = 2 // => новое значение: 2, старое значение: 1
  ```

  <p class="tip">Обратите внимание, что __вам не стоит использовать стрелочные функции при определении наблюдателей__ (напр. `searchQuery: newValue => this.updateAutocomplete(newValue)`). Поскольку стрелочные функции связываются с родительским контекстом, `this` не будет указывать на экземпляр Vue, и `this.updateAutocomplete` окажется неопределённым.</p>

- **См. также:** [Методы экземпляра — vm.$watch](#vm-watch)

## Опции — DOM

### el

- **Тип:** `string | HTMLElement`

- **Ограничение:** учитывается только при создании экземпляра выражением `new`.

- **Подробности:**

  Указывает, на какой существующий DOM-элемент смонтировать экземпляр Vue. Может быть строковым CSS-селектором или собственно объектом типа HTMLElement.

  После монтирования экземпляра, переданный или найденный по CSS-селектору элемент будет доступен в `vm.$el`.

  Если эта опция указана при создании экземпляра, компиляция начнётся сразу же. В остальных случаях, вызовите `vm.$mount()`, чтобы запустить компиляцию.

  <p class="tip">Указанный элемент служит только точкой монтирования. В отличии от Vue 1.x, он обязательно будет заменён DOM-ом, сгенерированным Vue. Поэтому не стоит монтировать в корневые элементы `<html>` или `<body>`.</p>

  <p class="tip">Если не указано ни `render`-функции, ни опции `template`, HTML-содержимое DOM-элемента, к которому производится монтирование будет использовано в качестве шаблона. В этом случае необходимо использовать сборку Runtime + Компилятор.</p>

- **См. также:**
  - [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)
  - [Runtime + Компилятор vs. Runtime-only](../guide/installation.html#Runtime-Компилятор-vs-Runtime-only)

### template

- **Тип:** `string`

- **Подробности:**

  Строковый шаблон с разметкой для экземпляра Vue. Этот шаблон **заменит** элемент в точке монтирования. Вся уже существующая разметка в точке монтирования будет проигнорирована, если в шаблоне нет слота распределения контента.

  Если строка начинается с `#`, она будет использована как querySelector, а в качестве строкового шаблона будет использован innerHTML элемента с указанным id. Так вы сможете включать шаблоны, из тегов вроде `<script type="x-template">`.

  <p class="tip">С точки зрения безопасности необходимо использовать только те шаблоны Vue, которым вы можете доверять. Никогда не используйте в качестве шаблона данные, вводимые пользователем.</p>

  <p class="tip">Если в опциях Vue указана `render`-функция, шаблон будет проигнорирован.</p>

- **См. также:**
  - [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)
  - [Распределение контента слотами](../guide/components.html#Распределение-контента-слотами)

### render

- **Тип:** `(createElement: () => VNode) => VNode`

- **Подробности:**

  Альтернатива строковым шаблонам, позволяющая задействовать все алгоритмические возможности JavaScript. `Render`-функция получает первым аргументом метод `createElement`, нужный для создания `VNode`-ов.

  Если компонент функциональный, вторым параметром передаётся `context`, дающий доступ к контекстным данным, так как функциональные компоненты не имеют экземпляров.

  <p class="tip">Функция в опции `render` имеет приоритет над `render`-функцией, скомпилированной из шаблона определённого в опции `template`, а также над шаблоном указанным в DOM-элементе, к которому будет выполняться монтирование, через опцию `el`.</p>

- **См. также:** [Render-функции и JSX](../guide/render-function.html)

### renderError

> Добавлено в версии 2.2.0+

- **Тип:** `(createElement: () => VNode, error: Error) => VNode`

- **Подробности:**

  **Работает только в режиме разработки.**

  Обеспечивает альтернативный рендер когда `render`-функция по умолчанию встречает ошибку. Эта ошибка будет передана в `renderError` в качестве второго аргумента. Это особенно полезно при использовании вместе с горячей перезагрузкой модулей.

- **Пример:**

  ``` js
  new Vue({
    render (h) {
      throw new Error('oops')
    },
    renderError (h, err) {
      return h('pre', { style: { color: 'red' }}, err.stack)
    }
  }).$mount('#app')
  ```

- **См. также:** [Render-функции и JSX](../guide/render-function.html)

## Опции — хуки жизненного цикла

Хук (hook — буквально "крючок") — функция, вызываемая в определённый момент жизненного цикла сущности, например, непосредственно перед или после создания компонента Vue. Хук позволяет расширить или изменить стандартное поведение на пользовательское.

<p class="tip">Контекст `this` хуков указывает на экземпляр Vue c данными, вычисляемыми свойствами и методами. Это значит, что __вам не следует использовать стрелочные функции для определения хуков жизненного цикла__ (напр. `created: () => this.fetchTodos()`). Поскольку стрелочные функции связываются с родительским контекстом, `this` не будет указывать на экземпляр Vue, и `this.fetchTodos` окажется неопределённым.</p>

### beforeCreate

- **Тип:** `Function`

- **Подробности:**

  Вызывается синхронно сразу после инициализации экземпляра, до настройки наблюдения за данными, механизмов слежения и событий.

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### created

- **Тип:** `Function`

- **Подробности:**

  Вызывается синхронно сразу после создания экземпляра. На этом этапе экземпляр закончил обработку опций и настроил наблюдение за данными, вычисляемые свойства, методы, коллбэки слежения и событий. Однако, фаза монтирования ещё не начата, и свойство `$el` ещё не доступно.

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### beforeMount

- **Тип:** `Function`

- **Подробности:**

  Вызывается перед началом монтирования, сразу перед первым вызовом функции `render`.

  **При рендеринге на стороне сервера этот хук не вызывается.**

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### mounted

- **Тип:** `Function`

- **Подробности:**

  Вызывается сразу после того как экземпляр был смонтирован, а взамен `el` создан `vm.$el`. Если корневой экземпляр смонтирован на элемент документа, `vm.$el` тоже будет элементом документа.

  Обратите внимание, что `mounted` **не гарантирует** что все дочерние компоненты будут уже примонтированы. Если вы хотите подождать пока не будут отрендерены все, то можете воспользоваться [vm.$nextTick](#vm-nextTick) внутри `mounted`:

  ``` js
  mounted: function () {
    this.$nextTick(function () {
      // Код, который будет запущен только после
      // отображения всех представлений
    })
  }
  ```

  **При рендеринге на стороне сервера этот хук не вызывается.**

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### beforeUpdate

- **Тип:** `Function`

- **Подробности:**

  Вызывается при изменении данных перед тем, как DOM будет обновляться. Это хорошее место для получения доступа к существующему DOM перед обновлением, например чтобы удалить добавленные слушатели событий.

  **Этот хук не вызывается во время рендеринга на стороне сервера, потому что на сервере выполняется только начальный рендеринг.**

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### updated

- **Тип:** `Function`

- **Подробности:**

  Вызывается после того, как виртуальный DOM был обновлён из-за изменения данных.

  DOM компонента будет уже обновлён к моменту вызова этого хука, поэтому вы можете выполнять операции связанные с DOM здесь. Тем не менее, в большинстве случаев старайтесь избегать изменения состояния в этом хуке. Для реагирования на изменение состояния лучше использовать [вычисляемые свойства](#computed) или [отслеживание с помощью watch](#watch).

  Обратите внимание, что `updated` **не гарантирует** что все дочерние компоненты будут уже перерендерены. Если вы хотите подождать пока не будут перерендерены все, то можете воспользоваться [vm.$nextTick](#vm-nextTick) внутри `updated`:

  ``` js
  updated: function () {
    this.$nextTick(function () {
      // Код, который будет запущен только после
      // обновления всех представлений
    })
  }
  ```

  **При рендеринге на стороне сервера этот хук не вызывается.**

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### activated

- **Тип:** `Function`

- **Подробности:**

  Вызывается при активации keep-alive компонента.

  **При рендеринге на стороне сервера этот хук не вызывается.**

- **См. также:**
  - [Встроенные компоненты — keep-alive](#keep-alive)
  - [Динамические компоненты — keep-alive](../guide/components.html#keep-alive)

### deactivated

- **Тип:** `Function`

- **Подробности:**

  Вызывается после деактивации keep-alive компонента.

  **При рендеринге на стороне сервера этот хук не вызывается.**

- **См. также:**
  - [Встроенные компоненты — keep-alive](#keep-alive)
  - [Динамические компоненты — keep-alive](../guide/components.html#keep-alive)

### beforeDestroy

- **Тип:** `Function`

- **Подробности:**

  Вызывается перед уничтожением экземпляра Vue. На этом этапе экземпляр всё ещё полностью функционален.

  **При рендеринге на стороне сервера этот хук не вызывается.**

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### destroyed

- **Тип:** `Function`

- **Подробности:**

  Вызывается после уничтожения экземпляра Vue. К моменту вызова этого хука, все директивы экземпляра Vue уже отвязаны, все подписчики событий удалены, а все дочерние экземпляры Vue уничтожены.

  **При рендеринге на стороне сервера этот хук не вызывается.**

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### errorCaptured

> Добавлено в версии 2.5.0+

- **Тип:** `(err: Error, vm: Component, info: string) => ?boolean`

- **Подробности:**

  Вызывается, когда фиксируется ошибка из любого дочернего компонента. Хук получает три аргумента: ошибку, экземпляр компонента, который вызвал ошибку, и строку, содержащую информацию где была зафиксирована ошибка. Хук может возвращать `false`, чтобы предотвратить дальнейшее распространение ошибки.

  <p class="tip">Вы можете изменить состояние компонента в этом хуке. Тем не менее, важно иметь в вашем шаблоне или `render`-функции условия, которые оборачивают другой контент при обнаружении ошибки; иначе компонент может попасть в бесконечный цикл рендеринга.</p>

  **Правила распространения ошибок**

  - По умолчанию все ошибки по-прежнему отправляются в глобальный обработчик `config.errorHandler`, если он был определён, поэтому эти ошибки всё равно могут быть отправлены например в сервис сбора аналитики из одного места в коде.

  - Если существует несколько хуков `errorCaptured` в цепочке наследования компонента или родительской цепочке, то все они будут вызваны с той же ошибкой.

  - Если сам хук `errorCaptured` выбрасывает ошибку, то обе этих ошибки (зафиксированная и выброшенная хуком) будут отправлены в глобальный обработчик `config.errorHandler`.

  - Хук `errorCaptured` может возвращать `false` чтобы предотвратить дальнейшее распространение ошибки. Это по существу означает "эта ошибка была обработана и её следует игнорировать". Это предотвратит вызов дополнительных хуков `errorCaptured` или глобального обработчика `config.errorHandler` для этой ошибки.

## Опции — ресурсы

### directives

- **Тип:** `Object`

- **Подробности:**

  Хэш директив, доступных экземпляру Vue.

- **См. также:** [Пользовательские директивы](../guide/custom-directive.html)

### filters

- **Тип:** `Object`

- **Подробности:**

  Хэш фильтров, доступных экземпляру Vue.

- **См. также:** [`Vue.filter`](#Vue-filter)

### components

- **Тип:** `Object`

- **Подробности:**

  Хэш компонентов, доступных экземпляру Vue.

- **См. также:** [Компоненты](../guide/components.html)

## Опции — композиция

### parent

- **Тип:** `экземпляр Vue`

- **Подробности:**

  Определяет родительский экземпляр для создаваемого. Устанавливает отношение "родитель-потомок" между ними. Родитель будет доступен дочернему экземпляру посредством `this.$parent`, а дочерний экземпляр будет добавлен в массив `$children` родителя.

  <p class="tip">Старайтесь реже использовать `$parent` и `$children` — этот механизм мы предусмотрели на крайний случай. Для общения между родителем и ребёнком лучше использовать входные параметры и события.</p>

### mixins

- **Тип:** `Array<Object>`

- **Подробности:**

  Массив объектов-примесей. Примеси могут содержать те же опции, что и обычные объекты экземпляров Vue — они будут добавлены к основным опциям согласно логике `Vue.extend()`. Например, если и примесь и объект экземпляра содержат хук `created`, то будут вызваны оба.

  Хуки примесей вызываются в порядке их определения, до вызова собственных хуков компонента.

- **Пример:**

  ``` js
  var mixin = {
    created: function () { console.log(1) }
  }
  var vm = new Vue({
    created: function () { console.log(2) },
    mixins: [mixin]
  })
  // => 1
  // => 2
  ```

- **См. также:** [Примеси](../guide/mixins.html)

### extends

- **Тип:** `Object | Function`

- **Подробности:**

  Позволяет декларативно наследоваться от другого компонента (который может быть либо простым объектом, либо конструктором), не используя `Vue.extend`. Главным образом предназначено для облегчения наследования между компонентами, определёнными в одном файле.

  Эта функциональность похожа на `mixins`.

- **Пример:**

  ``` js
  var CompA = { ... }

  // наследуем от CompA, не вызывая `Vue.extend`:
  var CompB = {
    extends: CompA,
    ...
  }
  ```

### provide / inject

> Добавлено в версии 2.2.0+

- **Тип:**
  - **provide:** `Object | () => Object`
  - **inject:** `Array<string> | { [key: string]: string | Symbol | Object }`

- **Подробности:**

  <p class="tip">`provide` и `inject` в первую очередь предназначены для особых случаев использования в плагинах или компонентах библиотек. Их **не рекомендуется** использовать в коде приложения.</p>

  Эта пара опций используется вместе, чтобы позволить компоненту-родителю внедрять зависимости во всех его компонентах-потомках, независимо от того, насколько глубоко в иерархии они находятся, пока они находятся в той же самой родительской цепочке. Если вы знакомы с React, это очень похоже на функцию контекста.

  Опция `provide` должна быть объектом или функцией, возвращающей объект. Этот объект содержит свойства, которые будут доступны для внедрения в их потомках. Вы можете использовать ES2015 Symbols в качестве ключей этого объекта, но только в окружениях, которые нативно поддерживают `Symbol` и `Reflect.ownKeys`.

  Опция `inject` должна быть:
  - массивом строк, или
  - объектом, где ключи стоят для локального связывания имени, а значение является:
    - ключом (string или Symbol) для поиска в доступных инъекциях, или
    - объектом, где:
      - свойство `name` является ключом (string или Symbol) для поиска в доступных инъекциях, и
      - свойство `default` используется как резервное значение
      
  > Примечание: привязки `provide` и `inject` НЕ РЕАКТИВНЫ. Это сделано намеренно. Тем не менее, если вы передаёте вниз отслеживаемый объект, свойства на этом объекте остаются реактивными.

- **Пример:**

  ``` js
  var Provider = {
    provide: {
      foo: 'bar'
    },
    // ...
  }

  var Child = {
    inject: ['foo'],
    created () {
      console.log(this.foo) // => "bar"
    }
    // ...
  }
  ```

  С помощью ES2015 Symbols, функция `provide` и объект `inject`:

  ``` js
  const s = Symbol()

  const Provider = {
    provide () {
      return {
        [s]: 'foo'
      }
    }
  }

  const Child = {
    inject: { s },
    // ...
  }
  ```

  > Следующие два примера работают в версии Vue 2.2.1+. Ниже этой версии, внедрённые значения устанавливаются после инициализации `props` и `data`.

  Использование внедрённого значения, значением по умолчанию для входных данных:
  ```js
  const Child = {
    inject: ['foo'],
    props: {
      bar: {
        default () {
          return this.foo
        }
      }
    }
  }
  ```

  Использование внедрённого значения в качестве данных:
  ```js
  const Child = {
    inject: ['foo'],
    data () {
      return {
        bar: this.foo
      }
    }
  }
  ```

  > С версии 2.5.0+ инъекции могут быть необязательными со значением по умолчанию:

  ``` js
  const Child = {
    inject: {
      foo: { default: 'foo' }
    }
  }
  ```

  Если потребуется внедрить значение из свойства с другим именем, используйте `from` для обозначения свойства-источника:

  ``` js
  const Child = {
    inject: {
      foo: {
        from: 'bar',
        default: 'foo'
      }
    }
  }
  ```

  Аналогично значениям по умолчанию входных параметров, вам нужно использовать функцию фабрику для не-примитивных значений:

  ``` js
  const Child = {
    inject: {
      foo: {
        from: 'bar',
        default: () => [1, 2, 3]
      }
    }
  }
  ```

## Опции — разное

### name

- **Тип:** `string`

- **Ограничение:** учитывается только при определении компонента.

- **Подробности:**

  Название компонента. Позволяет компоненту рекурсивно вызывать самого себя в шаблоне. Обратите внимание что когда компонент регистрируется глобально посредством `Vue.component()`, глобальный ID автоматически устанавливается равным его имени.

  Кроме того, компоненты с указанным `name` проще отлаживать из-за более понятных сообщений в консоли. Во [Vue-devtools](https://github.com/vuejs/vue-devtools) все безымянные компоненты довольно неинформативно называются `<AnonymousComponent>`. Указание имён для компонентов значительно улучшает ситуацию.

### delimiters

- **Тип:** `Array<string>`

- **По умолчанию:** `{% raw %}["{{", "}}"]{% endraw %}`

- **Ограничения:** Эта опция доступна только в полной сборке, поддерживающей компиляцию шаблонов в браузере.

- **Подробности:**

  Разделители, выделяющие текст для интерполяции.

- **Пример:**

  ``` js
  new Vue({
    delimiters: ['${', '}']
  })

  // Разделители изменены на стиль строк-шаблонов в ES6
  ```

### functional

- **Тип:** `boolean`

- **Подробности:**

  Превращает компонент в функциональный, то есть не имеющий собственного состояния (`data`) и своего экземпляра (`this`). Такие компоненты по сути — просто `render`-функция, возвращающая узлы виртуального DOM. Это сильно ускоряет их рендеринг.

- **См. также:** [Функциональные компоненты](../guide/render-function.html#Функциональные-компоненты)

### model

> Добавлено в версии 2.2.0+

- **Тип:** `{ prop?: string, event?: string }`

- **Подробности:**

  Позволяет настроить входной параметр и событие, используемые для работы `v-model`. По умолчанию, `v-model` на компоненте использует входной параметр `value` и событие `input`. Но для некоторых типов полей, таких как чекбоксы и радио-кнопки, может потребоваться использовать входной параметр `value` для других целей. Использование опции `model` позволит избежать конфликта в таких случаях.

- **Пример:**

  ``` js
  Vue.component('my-checkbox', {
    model: {
      prop: 'checked',
      event: 'change'
    },
    props: {
      // это позволит использовать входной параметр `value` для других целей
      value: String,
      // используйте `checked` в качестве параметра, который заменяет `value`
      checked: {
        type: Number,
        default: 0
      }
    },
    // ...
  })
  ```

  ``` html
  <my-checkbox v-model="foo" value="some value"></my-checkbox>
  ```

  Указанное выше эквивалентно:

  ``` html
  <my-checkbox
    :checked="foo"
    @change="val => { foo = val }"
    value="some value">
  </my-checkbox>
  ```

### inheritAttrs

> Добавлено в версии 2.4.0+

- **Тип:** `boolean`

- **По умолчанию:** `true`

- **Подробности:**

  По умолчанию атрибуты из родительской области видимости, которые не были распознаны как входные параметры, будут "проваливаться" и применяться к корневому элементу дочернего компонента как обычные HTML-атрибуты. При создании компонента, который оборачивает элемент или другой компонент, это не всегда может быть ожидаемым поведением. Устанавливая `inheritAttrs` в `false`, это поведение по умолчанию может быть отключено. Атрибуты доступны через свойство экземпляра `$attrs` (также добавленное в версии 2.4.0) и могут быть явно привязаны к некорневому элементу с использованием `v-bind`.

  Примечание: эта опция **не влияет** на привязки `class` и `style`.

### comments

> Добавлено в версии 2.4.0+

- **Тип:** `boolean`

- **По умолчанию:** `false`

- **Ограничения:** Эта опция доступна только в полной сборке, поддерживающей компиляцию шаблонов в браузере.

- **Подробности:**

  Когда установлено в значение `true`, будут сохраняться и рендериться HTML-комментарии, найденные в шаблонах. Поведение по умолчанию выбрасывает их.

## Свойства экземпляра

### vm.$data

- **Тип:** `Object`

- **Подробности:**

  Объект с данными, над которым экземпляр Vue осуществляет наблюдение. Экземпляр проксирует сюда вызовы своих полей. (Например, `vm.a` будет указывать на `vm.$data.a`)

- **См. также:** [Опции — данные](#data)

### vm.$props

> Добавлено в версии 2.2.0+

- **Тип:** `Object`

- **Подробности:**

  Объект, предоставляющий доступ к текущим входным данным компонента. Экземпляр Vue проксирует доступ к свойствам своего объекта входных данных.

### vm.$el

- **Тип:** `HTMLElement`

- **Только для чтения**

- **Подробности:**

  Корневой элемент DOM, управляемый экземпляром Vue.

### vm.$options

- **Тип:** `Object`

- **Только для чтения**

- **Подробности:**

  Опции, переданные в конструктор экземпляра Vue. Полезно, если вы хотите передавать туда собственные опции:

  ``` js
  new Vue({
    customOption: 'что-нибудь',
    created: function () {
      console.log(this.$options.customOption) // => 'что-нибудь'
    }
  })
  ```

### vm.$parent

- **Тип:** `экземпляр Vue`

- **Только для чтения**

- **Подробности:**

  Экземпляр родителя, если он есть у текущего экземпляра.

### vm.$root

- **Тип:** `экземпляр Vue`

- **Только для чтения**

- **Подробности:**

  Корневой экземпляр Vue текущего дерева компонентов. Если у экземпляра нет родителя, в этом поле будет он сам.

### vm.$children

- **Тип:** `Array<экземпляр Vue>`

- **Только для чтения**

- **Подробности:**

  Компоненты-потомки экземпляра. **Обратите внимание, что порядок следования элементов в `$children` не гарантируется, и этот массив не реактивен.** Вместо того, чтобы использовать `$children` для связывания данных, попробуйте использовать обычный массив и директиву `v-for` для создания дочерних компонентов, и используйте этот массив как "источник истины".

### vm.$slots

- **Тип:** `{ [name: string]: ?Array<VNode> }`

- **Только для чтения**

- **Подробности:**

  Используется для доступа к контенту, [распределяемому слотами](../guide/components.html#Распределение-контента-слотами). У каждого [именованного слота](../guide/components.html#Именованные-слоты) есть соответствующее значение (например, содержимое `slot="foo"` попадёт в `vm.$slots.foo`). Свойство `default` содержит узлы, не включённые в именованные слоты.

  Особенно полезно `vm.$slots` в компонентах с [render-функциями](../guide/render-function.html).

- **Пример:**

  ```html
  <blog-post>
    <h1 slot="header">
      Обо мне
    </h1>

    <p>Этот контент попадёт в vm.$slots.default, потому что он не в именованном слоте.</p>

    <p slot="footer">
      Copyright 2016 Evan You
    </p>

    <p>Этот контент тоже попадёт в vm.$slots.default.</p>.
  </blog-post>
  ```

  ```js
  Vue.component('blog-post', {
    render: function (createElement) {
      var header = this.$slots.header
      var body   = this.$slots.default
      var footer = this.$slots.footer
      return createElement('div', [
        createElement('header', header),
        createElement('main', body),
        createElement('footer', footer)
      ])
    }
  })
  ```

  - [Компонент `<slot>`](#slot-1)
  - [Распределение контента слотами](../guide/components.html#Распределение-контента-слотами)
  - [Render-функции — слоты](../guide/render-function.html#Слоты)

### vm.$scopedSlots

> Добавлено в версии 2.1.0+

- **Тип:** `{ [name: string]: props => VNode | Array<VNode> }`

- **Только для чтения**

- **Подробности:**

  Используется для доступа к [слотам с ограниченной областью видимости](../guide/components.html#Слоты-с-ограниченной-областью-видимости). Для каждого слота, включая и слот `default`, объект содержащий соответствующую функцию, что возвращает VNode.

  Использование `vm.$scopedSlots` наиболее полезно при написании компонентов с использованием [render-функций](../guide/render-function.html).

- **См. также:**
  - [`<slot>` компонент](#slot-1)
  - [Слоты с ограниченной областью видимости](../guide/components.html#Слоты-с-ограниченной-областью-видимости)
  - [Render-функции — слоты](../guide/render-function.html#Слоты)

### vm.$refs

- **Тип:** `Object`

- **Только для чтения**

- **Подробности:**

  Объект, с дочерними компонентами, имеющими параметр `ref`.

- **См. также:**
  - [Ссылки на компоненты-потомки](../guide/components.html#Ссылки-на-компоненты-потомки)
  - [Специальный атрибут — ref](#ref)

### vm.$isServer

- **Тип:** `boolean`

- **Только для чтения**

- **Подробности:**

  Запущен ли данный экземпляр Vue на сервере.

- **См. также:** [SSR. Рендеринг на стороне сервера](../guide/ssr.html)

### vm.$attrs

- **Тип:** `{ [key: string]: string }`

- **Только для чтения**

- **Подробности:**

  Содержит нераспознанные атрибуты (за исключением `class` и `style`), указанные для компонента в родительской области видимости. Если у компонента нет объявленных входных параметров, здесь окажутся все атрибуты (кроме `class` и `style`). Эти атрибуты можно передавать вниз во внутренние компоненты через `v-bind="$attrs"` — что может быть полезным при создании компонентов высшего порядка (HOC).

### vm.$listeners

- **Тип:** `{ [key: string]: Function | Array<Function> }`

- **Только для чтения**

- **Подробности:**

  Содержит обработчики событий `v-on` из родительской области видимости (без модификаторов `.native`). Они могут быть переданы во внутренние компоненты через `v-on="$listeners"` — что может быть полезным при создании компонентов высшего порядка (HOC).

## Методы экземпляра — данные

### vm.$watch( expOrFn, callback, [options] )

- **Аргументы:**
  - `{string | Function} expOrFn`
  - `{Function | Object} callback`
  - `{Object} [options]`
    - `{boolean} deep`
    - `{boolean} immediate`

- **Возвращает:** `{Function} unwatch`

- **Использование:**

  Запускает наблюдение за выражением или вычисляемой функцией на предмет изменений. В параметры коллбэка будут переданы новое и старое значения отслеживаемого объекта. Выражение может быть только простым путём до переменной с разделителями-точками. Для более сложных случаев используйте функцию.

  <p class="tip">Обратите внимание: когда изменяете (а не заменяете) объект или массив, старое и новое значения при вызове коллбэка будут совпадать, так как они ссылаются на один и тот же объект или массив. Vue не сохраняет копии объекта на момент, предшествовавший изменениям.</p>

- **Пример:**

  ``` js
  // следим за переменной, указанной путём:
  vm.$watch('a.b.c', function (newVal, oldVal) {
    // переменная изменилась, сделайте что-нибудь
  })

  // следим за функцией:
  vm.$watch(
    function () {
      return this.a + this.b
    },
    function (newVal, oldVal) {
      // значение функции изменилось, сделайте что-нибудь
    }
  )
  ```

  `vm.$watch` возвращает функцию unwatch, которая останавливает слежение:

  ``` js
  var unwatch = vm.$watch('a', cb)
  // позднее, останавливаем слежение:
  unwatch()
  ```

- **Опция: deep**

  Чтобы слежение реагировало на изменения во вложенных объектах, передайте `deep: true` в объекте параметров. Обратите внимание, что для наблюдения за изменениями массивов этого не требуется.

  ``` js
  vm.$watch('someObject', callback, {
    deep: true
  })
  vm.someObject.nestedValue = 123
  // вызывается callback
  ```

- **Опция: immediate**

  Если передано `immediate: true`, коллбэк будет вызван сразу же после начала наблюдения с текущим значением выражения:

  ``` js
  vm.$watch('a', callback, {
    immediate: true
  })
  // `callback` вызывается сразу, с текущим значением `a`
  ```

### vm.$set( target, key, value )

- **Аргументы:**
  - `{Object | Array} target`
  - `{string | number} key`
  - `{any} value`

- **Возвращает:** установленное значение.

- **Использование:**

  **Псевдоним** глобального метода `Vue.set`.

- **См. также:** [Vue.set](#Vue-set)

### vm.$delete( target, key )

- **Аргументы:**
  - `{Object | Array} target`
  - `{string | number} key`

- **Использование:**

  **Псевдоним** глобального метода `Vue.delete`.

- **См. также:** [Vue.delete](#Vue-delete)

## Методы экземпляра — события

### vm.$on( event, callback )

- **Аргументы:**
  - `{string | Array<string>} event` (массив поддерживается только в версиях 2.2.0+)
  - `{Function} callback`

- **Использование:**

  Создаёт подписку на пользовательское событие текущего vm. Такое событие можно породить функцией `vm.$emit`. Коллбэк получит все дополнительные аргументы, переданные этому методу.

- **Пример:**

  ``` js
  vm.$on('test', function (msg) {
    console.log(msg)
  })
  vm.$emit('test', 'привет')
  // => "привет"
  ```

### vm.$once( event, callback )

- **Аргументы:**
  - `{string} event`
  - `{Function} callback`

- **Использование:**

  Создаёт подписку на пользовательское событие, но срабатывает только один раз. После первого же использования подписчик будет удалён.

### vm.$off( [event, callback] )

- **Аргументы:**
  - `{string | Array<string>} event` (массив поддерживается только в 2.2.2+)
  - `{Function} [callback]`

- **Использование:**

  Удаляет пользовательские подписчики события.

  - Если функция вызвана без параметров, она удалит все подписки на события;

  - Если указан только тип события — удалит все подписки указанного события;

  - Если указан и тип события, и коллбэк — будет удалена именно эта подписка именно этого события.

### vm.$emit( event, [...args] )

- **Аргументы:**
  - `{string} event`
  - `[...args]`

  Порождает событие в текущем экземпляре. Все дополнительно указанные параметры будут переданы в коллбэк подписки.

## Методы экземпляра — жизненный цикл

### vm.$mount( [elementOrSelector] )

- **Аргументы:**
  - `{Element | string} [elementOrSelector]`
  - `{boolean} [hydrating]`

- **Возвращает:** `vm` — сам экземпляр

- **Использование:**

  Если при создании экземпляра Vue не была указана опция `el`, он окажется в "непримонтированном" (unmounted) состоянии, то есть без ассоциированного элемента DOM. Вызовите `vm.$mount()`, чтобы примонтировать такой экземпляр.

  Если параметр `elementOrSelector` не указан, шаблон будет отрендерен как элемент вне документа. Вы сможете затем вставить такой элемент нативным интерфейсом DOM.

  Метод возвращает сам экземпляр, чтобы вы могли вызывать дополнительные методы по цепочке.

- **Пример:**

  ``` js
  var MyComponent = Vue.extend({
    template: '<div>Привет!</div>'
  })

  // создаём и монтируем в #app (заменит #app):
  new MyComponent().$mount('#app')

  // другой вариант записи, делает то же самое:
  new MyComponent({ el: '#app' })

  // рендерим вне документа и вставляем в DOM позднее:
  var component = new MyComponent().$mount()
  document.getElementById('app').appendChild(component.$el)
  ```

- **См. также:**
  - [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)
  - [SSR. Рендеринг на стороне сервера](../guide/ssr.html)

### vm.$forceUpdate()

- **Использование:**

  Заставляет экземпляр Vue произвести перерендеринг. Обратите внимание, что этот метод затронет не все дочерние компоненты, а только сам экземпляр и дочерние компоненты с контентными слотами.

### vm.$nextTick( [callback] )

- **Аргументы:**
  - `{Function} [callback]`

- **Использование:**

  Выполняет функцию `callback` при следующем цикле обновления DOM. Вызывайте сразу после изменения данных, чтобы работать с обновлённым DOM. Функция делает то же самое, что и глобальный `Vue.nextTick`, но кроме того связывает `this` с текущим экземпляром в коллбэке.

  > Добавлено в версии 2.1.0+: возвращает `Promise`, если окружение их поддерживает и коллбэк не указан. Обратите внимание, что Vue не поставляется с полифиллом для `Promise`. Поэтому при необходимости поддержки браузеров, которые не поддерживают их нативно (например, IE), вам придётся предоставить полифилл самостоятельно.

- **Пример:**

  ``` js
  new Vue({
    // ...
    methods: {
      // ...
      example: function () {
        // меняем данные:
        this.message = 'changed'
        // DOM ещё не обновлён
        this.$nextTick(function () {
          // теперь DOM обновлён
          // `this` указывает на текущий экземпляр
          this.doSomethingElse()
        })
      }
    }
  })
  ```

- **См. также:**
  - [Vue.nextTick](#Vue-nextTick)
  - [Асинхронная очередь обновлений](../guide/reactivity.html#Асинхронная-очередь-обновлений)

### vm.$destroy()

- **Использование:**

  Полностью уничтожает vm. Очищает связи с другими существующими vm, отвязывает директивы, отменяет все подписки на события.

  Вызывает хуки `beforeDestroy` и `destroyed`.

  <p class="tip">Как правило, вам не придётся вызывать этот метод самим. Лучше контролировать жизненный цикл дочерних компонентов в data-driven стиле директивами `v-if` и `v-for`.</p>

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

## Директивы

### v-text

- **Принимает:** `string`

- **Подробности:**

  Управляет текстовым содержимым элемента (`textContent`). Если вам нужно управлять только частью содержимого тега, используйте интерполяцию `{% raw %}{{ Mustache }}{% endraw %}`.

- **Пример:**

  ```html
  <span v-text="msg"></span>
  <!-- то же, что -->
  <span>{{msg}}</span>
  ```

- **См. также:** [Синтаксис шаблонов — интерполяции](../guide/syntax.html#Текст)

### v-html

- **Принимает:** `string`

- **Подробности:**

  Управляет HTML-содержимым элемента (`innerHTML`). **Обратите внимание, что содержимое вставляется как обычный HTML — то есть не компилируется как шаблон Vue**. Не стоит организовывать вложенные шаблоны с помощью `v-html`, попробуйте лучше применить компоненты.

  <p class="tip">Динамический рендеринг произвольного HTML-кода на сайте — это очень опасная практика, легко приводящая к [XSS-уязвимостям](https://ru.wikipedia.org/wiki/Межсайтовый_скриптинг). Передавайте в `v-html` только содержимое, которому можно доверять, и **никогда** — необработанный пользовательский ввод.</p>

  <p class="tip">В [однофайловых компонентах](../guide/single-file-components.html) `scoped` стили не будут применены к содержимому внутри `v-html`, потому что этот HTML не обрабатывается компилятором шаблонов Vue. Если вы хотите стилизовать содержимое `v-html` с помощью локального CSS, то вы можете вместо этого использовать [CSS-модули](https://vue-loader.vuejs.org/ru/features/css-modules.html) или дополнительный глобальный элемент `<style>` с иной стратегией, такой как БЭМ.</p>

- **Пример:**

  ```html
  <div v-html="html"></div>
  ```

- **См. также:** [Синтаксис шаблонов — интерполяции](../guide/syntax.html#Сырой-HTML)

### v-show

- **Принимает:** `any`

- **Использование:**

  Переключает CSS-свойство `display` элемента, в зависимости от того, истинно ли указанное выражение.

  При изменении состояния этой директивы вызываются анимации, заданные в transition.

- **См. также:** [Условный рендеринг — v-show](../guide/conditional.html#v-show)


### v-if

- **Принимает:** `any`

- **Использование:**

  Осуществляет рендеринг элемента, только если передаваемое выражение истинно. При изменении значения выражения на противоположное, элемент и содержащиеся в нём компоненты и директивы уничтожаются/пересоздаются. Если элемент — `<template>`, вместо него будет отрендерено его содержимое.

  Эта директива также запускает анимационные переходы при изменении условия.

  <p class="tip">При совместном использовании `v-if` и `v-for`, `v-for` имеет более высокий приоритет. Подробности на странице [рендеринга списков](../guide/list.html#v-for-и-v-if).</p>

- **См. также:** [Условный рендеринг — v-if](../guide/conditional.html#v-if)


### v-else

- **Не принимает какое-либо выражение**

- **Ограничение:** предыдущий элемент должен иметь директиву `v-if` или `v-else-if`.

- **Использование:**

  Определяет "блок else" для `v-if` или цепочки `v-if`/`v-else-if`.

  ```html
  <div v-if="Math.random() > 0.5">
    Сейчас меня видно
  </div>
  <div v-else>
    А сейчас — нет
  </div>
  ```

- **См. также:** [Условный рендеринг — v-else](../guide/conditional.html#v-else)

### v-else-if

> Добавлено в версии 2.1.0+

- **Ожидает:** `any`

- **Ограничение:** предшествующий элемент должен иметь `v-if` или `v-else-if`.

- **Использование:**

  Обозначает "блок else if" для `v-if`. Можно объединять в цепочки.

  ```html
  <div v-if="type === 'A'">
    A
  </div>
  <div v-else-if="type === 'B'">
    B
  </div>
  <div v-else-if="type === 'C'">
    C
  </div>
  <div v-else>
    Не A/B/C
  </div>
  ```

- **См. также:** [Условный рендеринг — v-else-if](../guide/conditional.html#v-else-if)

### v-for

- **Принимает:** `Array | Object | number | string`

- **Использование:**

  Многократно рендерит элемент или блок шаблона, основываясь на переданных данных. Значение директивы должно следовать синтаксису `alias in expression` — в `alias` будет элемент текущей итерации:

  ``` html
  <div v-for="item in items">
    {{ item.text }}
  </div>
  ```

   Кроме того, вы можете указать название для индекса (или ключа, если вы работаете с объектом):

  ``` html
  <div v-for="(item, index) in items"></div>
  <div v-for="(val, key) in object"></div>
  <div v-for="(val, key, index) in object"></div>
  ```

  По умолчанию `v-for` будет пытаться обновить элементы "на месте", не перемещая их. Если вам нужно, чтобы элементы перемещались, сохраняя явную упорядоченность, укажите атрибут `key`:

  ``` html
  <div v-for="item in items" :key="item.id">
    {{ item.text }}
  </div>
  ```

  <p class="tip">При совместном использовании `v-if` и `v-for`, `v-for` имеет более высокий приоритет. Подробности на странице [рендеринга списков](../guide/list.html#v-for-и-v-if").</p>

  Использование `v-for` подробно описано в секции руководства по ссылке ниже.

- **См. также:**
  - [Рендеринг списков](../guide/list.html)
  - [key](../guide/list.html#key)

### v-on

- **Сокращение:** `@`

- **Принимает:** `Function | Inline-выражение | Object`

- **Параметр:** `event`

- **Модификаторы:**
  - `.stop` — вызовет `event.stopPropagation()`.
  - `.prevent` — вызовет `event.preventDefault()`.
  - `.capture` — добавит подписку в режиме capture.
  - `.self` — вызовет обработчик только если событие возникло непосредственно на этом элементе.
  - `.{keyCode | keyAlias}` — вызывает обработчик только при нажатии определённой клавиши.
  - `.native` — подписаться на нативное событие на корневом элементе компонента.
  - `.once` — вызовет обработчик не больше одного раза.
  - `.left` - (2.2.0) вызов обработчика только по событию нажатия левой кнопки мыши.
  - `.right` - (2.2.0) вызов обработчика только по событию нажатия правой кнопки мыши.
  - `.middle` - (2.2.0) вызов обработчика только по событию нажатия средней кнопки мыши.
  - `.passive` - (2.3.0+) вызов обработчика события DOM с опцией `{ passive: true }`.

- **Использование:**

  Прикрепляет к элементу подписчик события. Тип события указывается в параметре. Выражение может быть именем метода, inline-выражением или вовсе отсутствовать, если указан один или несколько модификаторов.

  Начиная с версии 2.4.0+, `v-on` также поддерживает привязку к объекту пар событие/обработчик без аргумента. Обратите внимание, что при использовании синтаксиса объекта не поддерживаются никакие модификаторы.

  У обычного элемента можно подписаться только [**на нативные события DOM**](https://developer.mozilla.org/en-US/docs/Web/Events). У элемента компонента можно подписаться **на пользовательские события**, вызываемые этим дочерним компонентом.

  При работе с нативными событиями DOM, метод получает нативное событие единственным аргументом. В inline-выражениях, можно получить к нему доступ с помощью `$event`: `v-on:click="handle('ok', $event)"`.

- **Пример:**

  ```html
  <!-- обработчик метода -->
  <button v-on:click="doThis"></button>

  <!-- синтаксис объекта (2.4.0+) -->
  <button v-on="{ mousedown: doThis, mouseup: doThat }"></button>

  <!-- inline-выражение -->
  <button v-on:click="doThat('hello', $event)"></button>

  <!-- сокращённая запись -->
  <button @click="doThis"></button>

  <!-- модификатор stop propagation -->
  <button @click.stop="doThis"></button>

  <!-- модификатор prevent default -->
  <button @click.prevent="doThis"></button>

  <!-- модификатор prevent default без дополнительных действий -->
  <form @submit.prevent></form>

  <!-- цепочка из модификаторов -->
  <button @click.stop.prevent="doThis"></button>

  <!-- модификатор клавиши keyAlias -->
  <input @keyup.enter="onEnter">

  <!-- модификатор клавиши keyCode -->
  <input @keyup.13="onEnter">

  <!-- обработчик метода будет вызван не больше одного раза -->
  <button v-on:click.once="doThis"></button>
  ```

  Подписка на пользовательское событие в дочернем элементе (обработчик вызывается, когда дочерний элемент вызывает "my-event"):

  ```html
  <my-component @my-event="handleThis"></my-component>

  <!-- inline-выражение -->
  <my-component @my-event="handleThis(123, $event)"></my-component>

  <!-- подписываемся на нативное событие в компоненте -->
  <my-component @click.native="onClick"></my-component>
  ```

- **См. также:**
  - [Обработка событий](../guide/events.html)
  - [Компоненты — пользовательские события](../guide/components.html#Пользовательские-события)

### v-bind

- **Сокращение:** `:`

- **Принимает:** `any (если указан параметр) | Object (если параметр не указан)`

- **Параметр:** `attrOrProp (опционально)`

- **Модификаторы:**
  - `.prop` — используется для связывания в качестве DOM-свойства, а не атрибута ([в чём разница?](https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028)). Если тег является компонентом, то `.prop` будет устанавливать свойство на `$el` компонента.
  - `.camel` — (2.1.0+) преобразует имена атрибутов из kebab-case в camelCase.
  - `.sync` — (2.3.0+) синтаксический сахар, который будет преобразован в обработчик `v-on` для обновления связанного значения.

- **Использование:**

  Динамически связывает атрибуты тега или входной параметр компонента с выражением.

  При использовании с атрибутами `class` и `style` поддерживает массивы и объекты в качестве значений. Подробнее это описано в соответствующем руководстве по ссылке ниже.

  Для правильного связывания входного параметра компонента, тот должен быть корректно определён в дочернем компоненте.

  Если аргумент не указан, связанное значение может быть содержащим пары имя-значение. Обратите внимание, что в этом случае атрибуты `class` и `style` не поддерживают массивы и объекты.

- **Пример:**

  ```html
  <!-- связывание атрибута -->
  <img v-bind:src="imageSrc">

  <!-- сокращение -->
  <img :src="imageSrc">

  <!-- поддержка конкатенации строк -->
  <img :src="'/path/to/images/' + fileName">

  <!-- связывание CSS-класса -->
  <div :class="{ red: isRed }"></div>
  <div :class="[classA, classB]"></div>
  <div :class="[classA, { classB: isB, classC: isC }]">

  <!-- связывание локального стиля -->
  <div :style="{ fontSize: size + 'px' }"></div>
  <div :style="[styleObjectA, styleObjectB]"></div>

  <!-- связывание с объектом, содержащим атрибуты -->
  <div v-bind="{ id: someProp, 'other-attr': otherProp }"></div>

  <!-- связывание с атрибутами DOM при указании модификатора -->
  <div v-bind:text-content.prop="text"></div>

  <!-- связывание входного параметра. "prop" должен быть определён в my-component. -->
  <my-component :prop="someThing"></my-component>

  <!-- передача всех входных параметров компонента в child-component -->
  <child-component v-bind="$props"></child-component>

  <!-- XLink -->
  <svg><a :xlink:special="foo"></a></svg>
  ```

  Модификатор `.camel` позволяет перевод имени атрибута `v-bind` в camelCase при использовании DOM-шаблонов, например для атрибута `viewBox` SVG:

  ``` html
  <svg :view-box.camel="viewBox"></svg>
  ```

  В использовании `.camel` нет необходимости, если вы пользуетесь строковыми шаблонами или `vue-loader`/`vueify`.

- **См. также:**
  - [Работа с классами и стилями](../guide/class-and-style.html)
  - [Компоненты — входные параметры](../guide/components.html#Входные-параметры)
  - [Компоненты — модификатор `.sync`](../guide/components.html#Модификатор-sync)

### v-model

- **Принимает:** разное, в зависимости от типа форм или выходных данных компонентов

- **Используется только с:**
  - `<input>`
  - `<select>`
  - `<textarea>`
  - компонентами

- **Модификаторы:**
  - [`.lazy`](../guide/forms.html#lazy) — подписаться на события `change`, а не `input`
  - [`.number`](../guide/forms.html#number) — приводить введённую строку к числу
  - [`.trim`](../guide/forms.html#trim) — удалять пробелы в начале и в конце введённой строки

- **Использование:**

  Двусторонним образом связывает элемент ввода данных или компонент с переменной. Директива подробно описана в руководстве по ссылке ниже.

- **См. также:**
  - [Работа с формами](../guide/forms.html)
  - [Компоненты — поля ввода форм с использованием пользовательских событий](../guide/components.html#Поля-ввода-форм-с-использованием-пользовательских-событий)

### v-pre

- **Не принимает какое-либо выражение**

- **Использование:**

  Пропустить компиляцию для этого элемента и всех его потомков. Вы можете использовать это для отображения необработанных тегов `{% raw %}{{}}{% endraw %}`. Кроме того, пропуск большого количества элементов может ускорить компиляцию.

- **Пример:**

  ```html
  <span v-pre>{{ эта часть не будет скомпилирована }}</span>
   ```

### v-cloak

- **Не принимает какое-либо выражение**

- **Использование:**

  Эта директива останется на элементе до тех пор, пока связанный с ним экземпляр Vue не закончит компиляцию. В сочетании с CSS-правилом `[v-cloak] { display: none }` этой директивой можно скрывать нескомпилированные шаблоны до тех пор, пока экземпляр Vue не будет готов.

- **Пример:**

  ```css
  [v-cloak] {
    display: none;
  }
  ```

  ```html
  <div v-cloak>
    {{ message }}
  </div>
  ```

  Элемент `<div>` не появится, пока компиляция не закончится.

### v-once

- **Не принимает какое-либо выражение**

- **Использование:**

  **Однократно** рендерит элемент или компонент. При повторном рендеринге он, а также все его потомки, рассматриваются как статический контент и пропускаются. Это поможет увеличить производительность обновлений.

  ```html
  <!-- одиночный элемент -->
  <span v-once>Это никогда не изменится: {{msg}}</span>

  <!-- элемент с потомком -->
  <div v-once>
    <h1>comment</h1>
    <p>{{msg}}</p>
  </div>

  <!-- компонент -->
  <my-component v-once :comment="msg"></my-component>

  <!-- директива `v-for` -->
  <ul>
    <li v-for="i in list" v-once>{{i}}</li>
  </ul>
  ```

- **См. также:**
  - [Синтаксис шаблонов — интерполяции](../guide/syntax.html#Текст)
  - [Компоненты — дешёвые статические компоненты с `v-once`](../guide/components.html#“Дешёвые”-статические-компоненты-с-использованием-v-once)

## Специальные атрибуты

### key

- **Принимает:** `number | string`

  Атрибут `key` помогает алгоритму работы с виртуальным DOM определить, какие ноды соответствует какой строке данных. Если этот атрибут не указан, Vue использует алгоритм, минимизирующий перемещение элементов и старается обновить и повторно использовать как можно больше элементов правильного типа "на местах". А если ключ указан, Vue изменяет порядок следования элементов, основываясь на изменении порядка ключей. Элементы, соответствующие ключам, которых больше нет, Vue всегда уничтожает.

  Потомки одного и того же общего родителя должны иметь **уникальные ключи**. Повторяющиеся ключи приведут к ошибкам при рендеринге.

  Как правило, используется в связке с `v-for`:

  ``` html
  <ul>
    <li v-for="item in items" :key="item.id">...</li>
  </ul>
  ```

  Можно также применить эту директиву, чтобы элемент всегда заменялся на новый, а не переиспользовался. Это может помочь, если вы хотите:

  - Быть уверенным, что все хуки жизненного цикла компонента будут вызваны
  - Запускать анимации (например, установленные в transition)

  Например:

  ``` html
  <transition>
    <span :key="text">{{ text }}</span>
  </transition>
  ```

  При изменении `text`, `<span>` всегда будет заменяться целиком, что спровоцирует вызов анимации.

### ref

- **Принимает:** `string`

  Название элемента или компонента для регистрации ссылки на него. В объекте `$refs` появится поле с названием из этого атрибута и значением: элементом DOM, если атрибут стоял на простом теге или экземпляром компонента, если атрибут стоял на пользовательском компоненте:

  ``` html
  <!-- vm.$refs.p будет DOM-элементом -->

  <p ref="p">hello</p>

  <!-- vm.$refs.child будет указывать на экземпляр ChildComp -->
  <child-comp ref="child"></child-comp>
  ```

  При использовании на элементах/компонентах с `v-for`, регистрируется массив ссылок на элементы DOM или экземпляры компонентов.

  Важное замечание о времени регистрации ссылок: поскольку ссылки создаются `render`-функцией, вы не сможете использовать их при первичном рендеринге — на тот момент они ещё не существуют! Кроме того, объект `$refs` не является реактивным, поэтому не стоит пытаться использовать его в шаблонах для связывания данных.

- **См. также:** [Ссылки на компоненты-потомки](../guide/components.html#Ссылки-на-компоненты-потомки)

### slot

- **Принимает:** `string`

  Используется в содержимом дочерних компонентов для указания того, к какому из именованных слотов принадлежит отмеченный контент.

  Подробнее в руководстве по ссылке ниже.

- **См. также:** [Именованные слоты](../guide/components.html#Именованные-слоты)

### slot-scope

> Добавлено в версии 2.5.0+

- **Принимает:** `выражение аргумента функции`

- **Использование:**

  Используется для обозначения элемента или компонента в качестве слота с ограниченной областью видимости. Значением атрибута должно быть валидное выражение JavaScript, которое может использоваться в качестве аргумента сигнатуры функции. Это означает, что в поддерживаемых окружениях вы также можете использовать деструктурирование ES2015 в выражении. Служит заменой для [`scope`](#scope-replaced) в версии 2.5.0+.

  Этот атрибут не поддерживает динамические привязки.

- **См. также:** [Слоты с ограниченной областью видимости](../guide/components.html#Слоты-с-ограниченной-областью-видимости)

### scope <sup>заменено</sup>

Используется для обозначения элемента `<template>` в качестве слота с ограниченной областью видимости, который заменён на [`slot-scope`](#slot-scope) в версии 2.5.0+.

- **Использование:**

  Аналогично [`slot-scope`](#slot-scope) за исключением того, что `scope` может использоваться только на элементах `<template>`.

### is

- **Принимает:** `string`

  Используется для [динамически переключаемых компонентов](../guide/components.html#Динамическое-переключение-компонентов) и для обхода [ограничений при использовании DOM-шаблонов](../guide/components.html#Особенности-парсинга-DOM-шаблона).

  Например:

  ``` html
  <!-- используемый компонент меняется при изменениях currentView -->
  <component v-bind:is="currentView"></component>

  <!-- необходим, потому что `<my-row>` будет считаться невалидным -->
  <!-- элементом внутри `<table>` и будет вынесен выше             -->
  <table>
    <tr is="my-row"></tr>
  </table>
  ```

  Подробности использования можно изучить по ссылкам ниже.

- **См. также:**
  - [Динамическое переключение компонентов](../guide/components.html#Динамическое-переключение-компонентов)
  - [Особенности парсинга DOM-шаблона](../guide/components.html#Особенности-парсинга-DOM-шаблона)

## Встроенные компоненты

### component

- **Входные параметры:**
  - `is` — string | ComponentDefinition | ComponentConstructor
  - `inline-template` — boolean

- **Использование:**

  "Метакомпонент" для рендеринга динамических компонентов. Настоящий компонент для рендеринга определяется параметром `is`:

  ```html
  <!-- динамический компонент, контролируемый -->
  <!-- свойством vm `componentId`-->
  <component :is="componentId"></component>

  <!-- может также рендерить зарегистрированный или переданный параметром компонент -->
  <component :is="$options.components.child"></component>
  ```

- **См. также:** [Динамическое переключение компонентов](../guide/components.html#Динамическое-переключение-компонентов)

### transition

- **Входные параметры:**
  - `name` — string, используется для автоматической генерации имён CSS-классов для анимаций. Например, `name: 'fade'` автоматически раскроется в `.fade-enter`, `.fade-enter-active` и т. д. Значение по умолчанию — `"v"`.
  - `appear` — boolean, вызывать ли анимацию при первом рендеринге. По умолчанию `false`.
  - `css` — boolean, применять ли CSS-классы. По умолчанию `true`. Если установить в `false`, будут вызываться только обработчики JavaScript, зарегистрированные для событий компонента.
  - `type` — string, указывает тип событий, с помощью которых определяется момент завершения анимации. Доступные значения: `"transition"` и `"animation"`. По умолчанию автоматически выбирается тип, задающий наибольшую продолжительность.
  - `mode` — string, управляет порядком анимаций исчезновения и появления элементов. Доступные режимы `"out-in"` (сначала старый элемент исчезает, потом новый появляется) и `"in-out"` (сначала новый элемент появляется, потом исчезает старый). По умолчанию исчезновение и появление происходят одновременно.
  - `enter-class` — string
  - `leave-class` — string
  - `appear-class` — string
  - `enter-to-class` — string
  - `leave-to-class` — string
  - `appear-to-class` — string
  - `enter-active-class` — string
  - `leave-active-class` — string
  - `appear-active-class` — string

- **События:**
  - `before-enter`
  - `before-leave`
  - `before-appear`
  - `enter`
  - `leave`
  - `appear`
  - `after-enter`
  - `after-leave`
  - `after-appear`
  - `enter-cancelled`
  - `leave-cancelled` (только для `v-show`)
  - `appear-cancelled`

- **Использование:**

  Указывает анимацию перехода для **одного** элемента или компонента. `<transition>` не порождает дополнительного элемента DOM при рендеринге, и не отображается в иерархии компонентов в инспекторе. Этот компонент просто применяет поведение перехода к своему содержимому.

  ```html
  <!-- простой элемент -->
  <transition>
    <div v-if="ok">переключаемое содержимое</div>
  </transition>

  <!-- динамический компонент -->
  <transition name="fade" mode="out-in" appear>
    <component :is="view"></component>
  </transition>

  <!-- хук на событие -->
  <div id="transition-demo">
    <transition @after-enter="transitionComplete">
      <div v-show="ok">переключаемое содержимое</div>
    </transition>
  </div>
  ```

  ``` js
  new Vue({
    ...
    methods: {
      transitionComplete: function (el) {
        // сделайте что-нибудь с переданным элементом DOM ...
      }
    }
    ...
  }).$mount('#transition-demo')
  ```

- **См. также:** [Анимирование списков и появления/исчезновения](../guide/transitions.html)

### transition-group

- **Входные параметры:**
  - `tag` — string, по умолчанию используется `span`.
  - `move-class` — переопределяет CSS-класс, применяемый во время анимации перемещения.
  - те же атрибуты, что и у `<transition>` кроме `mode`.

- **События:**
  - те же, что и у `<transition>`.

- **Использование:**

  Указывает анимацию перехода для **нескольких** элементов или компонентов. `<transition-group>` превращается в реальный элемент DOM. По умолчанию для этого используется тег `<span>`, но можно указать любой другой в параметре `tag`.

  Обратите внимание, что каждый потомок `<transition-group>` должен иметь **уникальное значение key**, чтобы анимации работали корректно.

  Анимации перехода реализованы с помощью CSS-трансформаций. Когда позиция потомка изменилась после обновления, ему будет добавлен CSS-класс (автоматически сгенерированный из атрибута `name`, или же явно указанный в атрибуте `move-class`). Если после применения этого класса свойство `transform` можно будет анимировать, элемент будет с плавным переходом переведён туда, где он должен быть с помощью [техники FLIP](https://aerotwist.com/blog/flip-your-animations/).

  ```html
  <transition-group tag="ul" name="slide">
    <li v-for="item in items" :key="item.id">
      {{ item.text }}
    </li>
  </transition-group>
  ```

- **См. также:** [Анимирование списков и появления/исчезновения](../guide/transitions.html)

### keep-alive

- **Props:**
  - `include` — строка, регулярное выражение или массив. Только соответствующие компоненты будут кешироваться.
  - `exclude` — строка, регулярное выражение или массив. Все соответствующие компоненты не будут кешироваться.

- **Использование:**

  Оберните динамические компоненты тегом `<keep-alive>`, чтобы кешировать экземпляры интерактивных компонентов вместо того, чтобы их уничтожать. Так же, как и `<transition>`, `<keep-alive>` — абстрактный компонент: при рендеринге он не превращается в элемент DOM, и не показывается в цепочке родителей компонента.

  Когда компонент, расположенный внутри `<keep-alive>` показывается или скрывается, вызываются его хуки жизненного цикла `activated` или `deactivated` соответственно.

  > В версии 2.2.0+, `activated` и `deactivated` будет срабатывать для всех вложенных компонентов внутри `<keep-alive>` дерева.

  В основном используется для сохранения состояния компонента, чтобы избежать повторного рендеринга.

  ```html
  <!-- базовый вариант -->
  <keep-alive>
    <component :is="view"></component>
  </keep-alive>

  <!-- несколько потомков -->
  <keep-alive>
    <comp-a v-if="a > 1"></comp-a>
    <comp-b v-else></comp-b>
  </keep-alive>

  <!-- использование вместе с `<transition>` -->
  <transition>
    <keep-alive>
      <component :is="view"></component>
    </keep-alive>
  </transition>
  ```

  Обратите внимание, `<keep-alive>` предназначен для случая, когда есть один прямой дочерний компонент, который переключается. Он не будет работать, если в нём есть `v-for`. При наличии несколько дочерних компонентов отображаемых по условию, как указано выше, `<keep-alive>` требует, чтобы отображался только один дочерний компонент  в один момент времени.

- **`include` и `exclude`**

  > Добавлено в версии 2.1.0+

  Входные параметры `include` и `exclude` позволяют организовать условное кеширование компонентов. Оба параметра можно указать в виде строки со списком имён компонентов через запятую, регулярным выражением или массивом:

  ``` html
  <!-- строка с именами через запятую -->
  <keep-alive include="a,b">
    <component :is="view"></component>
  </keep-alive>

  <!-- регулярное выражение (используйте `v-bind`) -->
  <keep-alive :include="/a|b/">
    <component :is="view"></component>
  </keep-alive>

  <!-- массив (используйте `v-bind`) -->
  <keep-alive :include="['a', 'b']">
    <component :is="view"></component>
  </keep-alive>
  ```

  Проверяется сначала собственное значение опции `name` компонента, а в случае его недоступности — имя, указанное при локальной регистрации (ключ в опции `components` компонента-родителя). Анонимные компоненты таким образом проверить не получится.

  <p class="tip">`<keep-alive>` не работает с функциональными компонентами, так как у них отсутствуют экземпляры.</p>

- **См. также:** [Динамическое переключение компонентов — keep-alive](../guide/components.html#keep-alive)

### slot

- **Входные параметры:**
  - `name` — string, используется для именования слотов

- **Использование:**

  `<slot>` — элемент, чьё содержимое будет распределено в шаблон компонента. Сам элемент `<slot>` при рендеринге заменяется.

  Подробнее этот механизм описан в руководстве по ссылке ниже.

- **См. также:** [Распределение контента слотами](../guide/components.html#Распределение-контента-слотами)

## Интерфейс VNode

- Смотрите информацию об [объявлении классов VNode](https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js).

## Рендеринг на стороне сервера

- Смотрите [документацию пакета vue-server-renderer](https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer).
