---
type: api
---

## Глобальные параметры

`Vue.config` - это объект, содержащий глобальные параметры Vue. Перед загрузкой приложения можно изменить следующие свойства:

### silent

- **Тип:** `boolean`

- **По умолчанию:** `false`

- **Использование:**

  ``` js
  Vue.config.silent = true
  ```

  Отключает вывод логов и предупреждений Vue.

### optionMergeStrategies

- **Тип:** `{ [key: string]: Function }`

- **По умолчанию:** `{}`

- **Использование:**

  ``` js
  Vue.config.optionMergeStrategies._my_option = function (parent, child, vm) {
    return child + 1
  }

  const Profile = Vue.extend({
    _my_option: 1
  })

  // Profile.options._my_option = 2
  ```

  Меняет стратегию слияния опций на вашу собственную.

  Стратегия слияния получает значения опции родительского и дочернего элемента первым и вторым параметром соответственно.
  Третьим параметром передаётся контекст действующего инстанса Vue.

- **См. также:** [Пользовательские Методы Слияния Опций](/guide/mixins.html#Custom-Option-Merge-Strategies)

### devtools

- **Тип:** `boolean`

- **По умолчанию:** `true` (`false` в production-сборках)

- **Использование:**

  ``` js
  // убедитесь, что устанавливаете это свойство синхронно сразу после загрузки Vue
  Vue.config.devtools = true
  ```

  Указывает, должен ли Vue позволять инспекции [vue-devtools](https://github.com/vuejs/vue-devtools). Значение по умолчанию для development-окружения — `true`, для production-сборок — `false`. Установите `true`, чтобы vue-devtools работал и в production.

### errorHandler

- **Тип:** `Function`

- **По умолчанию:** Ошибка выбрасывается "на месте"

- **Использование:**

  ``` js
  Vue.config.errorHandler = function (err, vm) {
    // обработка ошибки
  }
  ```

  Устанавливает обработчик для ошибок, не пойманных во время рендеренга компонентов и в наблюдателях. Обработчик получит в параметрах ошибку и действующий инстанс Vue.

  > Сервис отслеживания ошибок [Sentry](https://sentry.io) предлагает [официальную интеграцию](https://sentry.io/for/vue/) с использованием этого свойства.

### keyCodes

- **Тип:** `{ [key: string]: number }`

- **По умолчанию:** `{}`

- **Использование:**

  ``` js
  Vue.config.keyCodes = {
    v: 86,
    f1: 112,
    mediaPlayPause: 179
  }
  ```

  Определяет один или несколько дополнительных алиасов для директивы v-on.

## Глобальный API

<h3 id="Vue-extend">Vue.extend( options )</h3>

- **Аргументы:**
  - `{Object} options`

- **Использование:**

  Создаёт "подкласс" базового конструктора Vue. Принимает параметром объект с опциями нового компонента.

  Внимание: у объекта, переданного в `Vue.extend()` свойство `data` должна быть функцией.

  ``` html
  <div id="mount-point"></div>
  ```

  ``` js
  // create constructor
  var Profile = Vue.extend({
    template: '<p>{{firstName}} {{lastName}}, также известный как {{alias}}</p>',
    data: function () {
      return {
        firstName: 'Уолтер',
        lastName: 'Уайт',
        alias: 'Гейзенберг'
      }
    }
  })
  // создаёт инстанс Profile и монтирует его к элементу DOM
  new Profile().$mount('#mount-point')
  ```

  Результатом будет:

  ``` html
  <p>Walter White aka Heisenberg</p>
  ```

- **См. также:** [Компоненты](/guide/components.html)

<h3 id="Vue-nextTick">Vue.nextTick( callback, [context] )</h3>

- **Аргументы:**
  - `{Function} callback`
  - `{Object} [context]`

- **Использование:**

  Выполняет функцию callback при следующем цикле обновления DOM. Вызывайте сразу после изменения данных, чтобы работать с обновлённым DOM.

  ``` js
  // modify data
  vm.msg = 'Привет'
  // DOM ещё не обновлён
  Vue.nextTick(function () {
    // теперь DOM обновлён
  })
  ```

- **См. также:** [Очередь асинхронных обновлений](/guide/reactivity.html#Async-Update-Queue)

<h3 id="Vue-set">Vue.set( object, key, value )</h3>

- **Аргументы:**
  - `{Object} object`
  - `{string} key`
  - `{any} value`

- **Возвращает:** установленное значение.

- **Использование:**

  Меняет значение поля. Если объект реактивный, поле тоже станет реактивным, а view обновится. Обычно нужен потому что Vue не может среагировать на неявное добавление полей.

  **Обратите внимание что объект не может быть инстансом Vue или корневым объектом data инстанса Vue.**

- **См. также:** [Подробно о реактивности](/guide/reactivity.html)

<h3 id="Vue-delete">Vue.delete( object, key )</h3>

- **Аргументы:**
  - `{Object} object`
  - `{string} key`

- **Использование:**

  Удаляет поле. Если объект реактивный, view обновится. Обычно нужен потому что Vue не может среагировать на неявное удаление полей (но вы вряд ли часто будете пользоваться этой функцией).

  **Обратите внимание что объект не может быть инстансом Vue или корневым объектом data инстанса Vue.**

- **См. также:** [Подробно о реактивности](/guide/reactivity.html)

<h3 id="Vue-directive">Vue.directive( id, [definition] )</h3>

- **Аргументы:**
  - `{string} id`
  - `{Function | Object} [definition]`

- **Использование:**

  Регистрирует новую глобальную директиву или возвращает уже зарегистрированную.

  ``` js
  // регистрируем директиву-объект:
  Vue.directive('my-directive', {
    bind: function () {},
    inserted: function () {},
    update: function () {},
    componentUpdated: function () {},
    unbind: function () {}
  })

  // региструем директиву в виде простой функции:
  Vue.directive('my-directive', function () {
    // Vue будет вызывать эту функцию как `bind` и `update`
  })

  // получаем определение директивы, если она зарегистрирована:
  var myDirective = Vue.directive('my-directive')
  ```

- **См. также:** [Пользовательские директивы](/guide/custom-directive.html)

<h3 id="Vue-filter">Vue.filter( id, [definition] )</h3>

- **Аргументы:**
  - `{string} id`
  - `{Function} [definition]`

- **Использование:**

  Регистрирует новый глобальный фильтр или возвращает уже зарегистрированный.

  ``` js
  // регистрируем фильтр:
  Vue.filter('my-filter', function (value) {
    // верните в функции результат обработки
  })

  // получаем фильтр, если он зарегистрирован:
  var myFilter = Vue.filter('my-filter')
  ```

<h3 id="Vue-component">Vue.component( id, [definition] )</h3>

- **Аргументы:**
  - `{string} id`
  - `{Function | Object} [definition]`

- **Использование:**

  Регистрирует новый глобальный компонент или возвращает уже зарегистрированный.

  ``` js
  // регистрируем конструктор, полученный из Vue.extend:
  Vue.component('my-component', Vue.extend({ /* ... */ }))

  // регистрируем объект с опциями (Vue вызовет для этого объекта Vue.extend автоматически):
  Vue.component('my-component', { /* ... */ })

  // получаем зарегистрированный компонент (всегда вернёт конструктор):
  var MyComponent = Vue.component('my-component')
  ```

- **См. также:** [Компоненты](/guide/components.html)

<h3 id="Vue-use">Vue.use( plugin )</h3>

- **Аргументы:**
  - `{Object | Function} plugin`

- **Использование:**

  Устанавливает плагин Vue.js. Если плагин — объект, у него должен быть публичный метод `install`. Если плагин — функция, она будет воспринята как метод install. Этот метод будет выполнен с Vue в качестве аргумента.

  Сколько бы раз вы не выполняли этот метод с одним и тем же плагином, плагин будет установлен только однажды.

- **См. также:** [Плагины](/guide/plugins.html)

<h3 id="Vue-mixin">Vue.mixin( mixin )</h3>

- **Аргументы:**
  - `{Object} mixin`

- **Использование:**

  Применяет миксин ко всем созданным впоследствии инстансам Vue. Так авторы плагинов могут встроить желаемое поведение в компоненты. **Не рекомендуем использовать в коде приложений**.

- **См. также:** [Глобальные миксины](/guide/mixins.html#Global-Mixin)

<h3 id="Vue-compile">Vue.compile( template )</h3>

- **Аргументы:**
  - `{string} template`

- **Использование:**

  Компилирует строковой шаблон в render-функцию. **Доступен только в автономной сборке.**

  ``` js
  var res = Vue.compile('<div><span>{{ msg }}</span></div>')

  new Vue({
    data: {
      msg: 'hello'
    },
    render: res.render,
    staticRenderFns: res.staticRenderFns
  })
  ```

- **См. также:** [Render-функции](/guide/render-function.html)

## Опции — данные

### data

- **Тип:** `Object | Function`

- **Ограничение:** При создании компонента, может быть только типа `Function`.

- **Подробности:**

  Объект с данными инстанса Vue. Vue рекурсивно переводит его поля в геттеры/сеттеры, и он становится "реактивным". **Объект должен быть простым**: Vue проигнорирует свойства прототипа и нативные объекты, как например из API браузера. Прежде всего, рекомендуем чтобы данные были просто данными — не стоит передавать сюда объекты с собственным управлением внутренним состоянием.

  Добавлять реактивные свойства к корневому объекту данных после его инициализации нельзя. Поэтому определяйте корневые реактивные свойства до создания инстанса.

  После создания инстанса, объект с данными доступен в `vm.$data`. Кроме того, инстанс Vue проксирует обнаруженные в нём свойства, так что `vm.a` эквивалентно `vm.$data.a`.

  Свойства, названия которых начинается с `_` или `$` **не** проксируются из-за возможных конфликтов со внутренними свойствами и методами API Vue. Доступ к таким свойствам возможен только через `vm.$data._property`.

  Для определения **компонента** `data` должен быть функцией, возвращающей объект для инициализации, потому что из одного определения компонента может быть создано несколько инстансов. Если бы мы использовали для `data` простой объект, все созданные инстансы получили бы **ссылку на него**! А когда `data` — функция, при создании нового инстанса можно вызвать её и получить свежую копию данных для инициализации.

  Чтобы получить полную копию оригинального объекта, передайте `vm.$data` в `JSON.parse(JSON.stringify(...))`.

- **Пример:**

  ``` js
  var data = { a: 1 }

  // создаём инстанс напрямую:
  var vm = new Vue({
    data: data
  })
  vm.a // -> 1
  vm.$data === data // -> true

  // обязательно используйте функцию во Vue.extend():
  var Component = Vue.extend({
    data: function () {
      return { a: 1 }
    }
  })
  ```

  <p class="tip">Обратите внимание, что __вам не стоит использовать arrow-функции в параметре `data`__ (напр. `data: () => { return { a: this.myProp }}`). Поскольку arrow-функции связываются с родительским контекстом, `this` не будет указывать на инстанс Vue и `this.myProp` окажется неопределенным.</p>

- **См. также:** [Подробно о реактивности](/guide/reactivity.html)

### props

- **Тип:** `Array<string> | Object`

- **Подробности:**

  Список или хэш аттрибутов, по которым разрешено получение данных от родительского компонента. Передайте простой массив названий или объект, задающий дополнительные параметры, например типы, правила валидации и значения по умолчанию.

- **Пример:**

  ``` js
  // простая форма записи:
  Vue.component('props-demo-simple', {
    props: ['size', 'myMessage']
  })

  // объект с указанием правил валидации:
  Vue.component('props-demo-advanced', {
    props: {
      // только проверка типа
      height: Number,
      // проверка типа и другие правила валидации
      age: {
        type: Number,
        default: 0,
        required: true,
        validator: function (value) {
          return value >= 0
        }
      }
    }
  })
  ```

- **См. также:** [Параметры компонентов](/guide/components.html#Props)

### propsData

- **Тип:** `{ [key: string]: any }`

- **Ограничение:** учитывается только при создании инстанса выражением `new`.

- **Подробности:**

  Параметры компонента при его создании. Обычно используется для тестирования.

- **Пример:**

  ``` js
  var Comp = Vue.extend({
    props: ['msg'],
    template: '<div>{{ msg }}</div>'
  })

  var vm = new Comp({
    propsData: {
      msg: 'привет'
    }
  })
  ```

### computed

- **Тип:** `{ [key: string]: Function | { get: Function, set: Function } }`

- **Подробности:**

  Вычисляемые свойства, которые будут подмешаны к инстансу Vue. В геттерах и сеттерах `this` будет указывать на инстанс Vue.

  <p class="tip">Обратите внимание, что __вам не стоит использовать arrow-функции при определении вычисляемых свойств__ (напр. `aDouble: () => this.a * 2`). Поскольку arrow-функции связываются с родительским контекстом, `this` не будет указывать на инстанс Vue, и `this.a` окажется неопределенным.</p>

  Вычисляемые свойства кэшируются и повторно вычисляются только при изменении реактивных зависимостей.

- **Пример:**

  ```js
  var vm = new Vue({
    data: { a: 1 },
    computed: {
      // если свойство только возвращает данные, достаточно простой функции:
      aDouble: function () {
        return this.a * 2
      },
      // свойство и возвращает, и получает данные:
      aPlus: {
        get: function () {
          return this.a + 1
        },
        set: function (v) {
          this.a = v - 1
        }
      }
    }
  })
  vm.aPlus   // -> 2
  vm.aPlus = 3
  vm.a       // -> 2
  vm.aDouble // -> 4
  ```

- **См. также:**
  - [Вычисляемые свойства](/guide/computed.html)

### methods

- **Тип:** `{ [key: string]: Function }`

- **Подробности:**

  Методы, которые будут подмешаны к инстансу Vue. Вы можете получить запустить эти методы прямо из инстанса VM, или использовать их в директивах. `this` методов указывает на инстанс Vue.

  <p class="tip">Обратите внимание, что __вам не стоит использовать arrow-функции при определении методов__ (напр. `plus: () => this.a++`). Поскольку arrow-функции связываются с родительским контекстом, `this` не будет указывать на инстанс Vue, и `this.a` окажется неопределенным.</p>

- **Пример:**

  ```js
  var vm = new Vue({
    data: { a: 1 },
    methods: {9
      plus: function () {
        this.a++
      }
    }
  })
  vm.plus()
  vm.a // 2
  ```

- **См. также:** [Методы и обработка событий](/guide/events.html)

### watch

- **Тип:** `{ [key: string]: string | Function | Object }`

- **Подробности:**

  Объект, ключи которого — выражения для наблюдения, а значения — коллбэки, вызываемые при их изменении. Значения также могут строками с именами методов, или объектами, содержащими дополнительные опции. Инстанс Vue вызовет `$watch()` соответствующий каждому ключа объекта при своём создании.

- **Пример:**

  ``` js
  var vm = new Vue({
    data: {
      a: 1,
      b: 2,
      c: 3
    },
    watch: {
      a: function (val, oldVal) {
        console.log('новое значение: %s, старое значение: %s', val, oldVal)
      },
      // строка с именем метода:
      b: 'someMethod',
      // глубокий (рекурсивный) наблюдатель:
      c: {
        handler: function (val, oldVal) { /* ... */ },
        deep: true
      }
    }
  })
  vm.a = 2 // -> new: 2, old: 1
  ```

  <p class="tip">Обратите внимание, что __вам не стоит использовать arrow-функции при определении наблюдателей__ (напр. `searchQuery: newValue => this.updateAutocomplete(newValue)`). Поскольку arrow-функции связываются с родительским контекстом, `this` не будет указывать на инстанс Vue, и `this.updateAutocomplete` окажется неопределенным.</p>

- **См. также:** [Методы инстанса - vm.$watch](#vm-watch)

## Опции — DOM

### el

- **Тип:** `string | HTMLElement`

- **Ограничение:** учитывается только при создании инстанса выражением `new`.

- **Подробности:**

  Указывает, на какой существующий DOM-элемент смонтировать инстанс Vue. Может быть строковым CSS-селектором или собственно объектом типа HTMLElement.

  После монтирования инстанса, переданный или найденный по CSS-селектору элемент будет доступен в `vm.$el`.

  Если эта опция указана при создании инстанса, компиляция начнётся сразу же. В остальных случаях, вызовите `vm.$mount()`, чтобы запустить компиляцию.

  <p class="tip">Указанный элемент служит только точкой монтирования. В отличии от Vue 1.x, он обязательно будет заменен DOM-ом, сгенерированным Vue. Поэтому не стоит монтировать в корневые элементы `<html>` или `<body>`.</p>

- **См. также:** [Диаграмма жизненного цикла](/guide/instance.html#Lifecycle-Diagram)

### template

- **Тип:** `string`

- **Подробности:**

  Строковый шаблон с разметкой для инстанса Vue. Этот шаблон **заменит** элемент в точке монтирования. Вся уже существующая разметка в точке монтирования будет проигнорирована, если в шаблоне нет слота распределения контента.

  Если строка начинается с `#`, она будет использована как querySelector, а в качестве строкового шаблона будет использован innerHTML элемента с указанным id. Так вы сможете включать шаблоны, из тегов вроде `<script type="x-template">`.

  <p class="tip">Чтобы оставаться в безопасности, используйте только те шаблоны Vue, которым можете доверять. Никогда не используйте в качестве шаблона данные, вводимые пользователем.</p>

- **См. также:**
  - [Диаграмма жизненного цикла](/guide/instance.html#Lifecycle-Diagram)
  - [Распределение контента слотами](/guide/components.html#Content-Distribution-with-Slots)

### render

  - **Тип:** `Function`

  - **Подробности:**

    Альтернатива строковым шаблонам, позволяющая задействовать все алгоритмические возможности JavaScript. Render-функция получает первым аргументом метод `createElement`, нужный для создания `VNode`-ов.

    Если компонент функциональный, вторым параметром передаётся `context`, дающий доступ к контекстным данным, так как функциональные компоненты не имеют инстансов.

  - **См. также:**
    - [Render-функции](/guide/render-function)

## Опции — Хуки жизненного цикла

Контекст `this` хуков указывает на инстанс Vue c данными, вычисляемыми свойствами и методами. Это значит, что __вам не следует использовать arrow-функции для определения хуков жизненного цикла__ (напр. `created: () => this.fetchTodos()`). Поскольку arrow-функции связываются с родительским контекстом, `this` не будет указывать на инстанс Vue, и `this.fetchTodos` окажется неопределенным.

### beforeCreate

- **Тип:** `Function`

- **Подробности:**

  Вызывается синхронно сразу после инициализации инстанса, до настройки наблюдения за данными, механизмов слежения и событий.

- **См. также:** [Диаграмма жизненного цикла](/guide/instance.html#Lifecycle-Diagram)

### created

- **Тип:** `Function`

- **Подробности:**

  Вызывается синхронно сразу после создания инстанса. На этом этапе инстанс закончил обработку опций и настроил наблюдение за данными, вычисляемые свойства, методы, коллбэки слежения и событий. Однако, фаза монтирования ещё не начата, и свойство `$el` ещё не доступно.

- **См. также:** [Диаграмма жизненного цикла](/guide/instance.html#Lifecycle-Diagram)

### beforeMount

- **Тип:** `Function`

- **Подробности:**

  Вызывается перед началом монтирования, сразу перед первым вызовом функции `render`.

  **При рендере на стороне сервера этот хук не вызывается.**

- **См. также:** [Диаграмма жизненного цикла](/guide/instance.html#Lifecycle-Diagram)

### mounted

- **Тип:** `Function`

- **Подробности:**

  Вызывается сразу после того как инстанс был смонтирован, а взамен `el` создан `vm.$el`. Если корневой инстанс смонтирован на элемент документа, `vm.$el` тоже будет элементом документа.

  **При рендере на стороне сервера этот хук не вызывается.**

- **См. также:** [Диаграмма жизненного цикла](/guide/instance.html#Lifecycle-Diagram)

### beforeUpdate

- **Тип:** `Function`

- **Подробности:**

  Вызывается при изменении данных, до перерендера и обновления виртуального DOM-а.

  В этом хуке можно дополнительно изменять состояние, и это не вызовет нового перерендера.

  **При рендере на стороне сервера этот хук не вызывается.**

- **См. также:** [Диаграмма жизненного цикла](/guide/instance.html#Lifecycle-Diagram)

### updated

- **Тип:** `Function`

- **Подробности:**

  Вызывается после того как виртуальный DOM был обновлён из-за изменения данных.

  DOM компонента уже будет обновлён к моменту вызова этого хука, поэтому можно выполнять зависящие от DOM операции. Старайтесь избегать изменения состояния в этом хуке, чтобы не попасть в бесконечный цикл обновления.

  **При рендере на стороне сервера этот хук не вызывается.**

- **См. также:** [Диаграмма жизненного цикла](/guide/instance.html#Lifecycle-Diagram)

### activated

- **Тип:** `Function`

- **Подробности:**

  Вызывается при активации keep-alive компонента.

  **При рендере на стороне сервера этот хук не вызывается.**

- **См. также:**
  - [Встроенные компоненты — keep-alive](#keep-alive)
  - [Динамические компоненты — keep-alive](/guide/components.html#keep-alive)

### deactivated

- **Тип:** `Function`

- **Подробности:**

  Вызывается после деактивации keep-alive компонента.

  **При рендере на стороне сервера этот хук не вызывается.**

- **См. также:**
  - [Встроенные компоненты - keep-alive](#keep-alive)
  - [Динамические компоненты - keep-alive](/guide/components.html#keep-alive)

### beforeDestroy

- **Тип:** `Function`

- **Подробности:**

  Вызывается перед уничтожением инстанса Vue. На этом этапе инстанс всё ещё полностью функционален.

  **При рендере на стороне сервера этот хук не вызывается.**

- **См. также:** [Диаграмма жизненного цикла](/guide/instance.html#Lifecycle-Diagram)

### destroyed

- **Тип:** `Function`

- **Подробности:**

  Вызывается после уничтожения инстанса Vue. К моменту вызова этого хука, все директивы инстанса Vue уже отвязаны, все слушатели событий удалены, а все дочерние инстансы Vue уничтожены.

  **При рендере на стороне сервера этот хук не вызывается.**

- **См. также:** [Диаграмма жизненного цикла](/guide/instance.html#Lifecycle-Diagram)

## Опции — ресурсы

### directives

- **Тип:** `Object`

- **Подробности:**

  Хэш директив, доступных инстансу Vue.

- **См. также:**
  - [Пользовательские директивы](/guide/custom-directive.html)
  - [Соглашение по именованию ресурсов](/guide/components.html#Assets-Naming-Convention)

### filters

- **Тип:** `Object`

- **Подробности:**

  Хэш фильтров, доступных инстансу Vue.

- **См. также:**
  - [`Vue.filter`](#Vue-filter)

### components

- **Тип:** `Object`

- **Подробности:**

  Хэш компонентов, доступных инстансу Vue.

- **См. также:**
  - [Компоненты](/guide/components.html)

## Опции — разное

### parent

- **Тип:** `инстанс Vue`

- **Подробности:**

  Указывает новому инстансу на родительский и устанавливает отношение "родитель-ребёнок" между ними. Родительский элемент будет доступен дочернему в `this.$parent`, а дочерний элемент будет добавлен в массив `$children` родителя.

  <p class="tip">Старайтесь реже использовать `$parent` и `$children` - этот механизм мы предусмотрели на крайний случай. Для общения между родителем и ребёнком лучше использовать свойства и события.</p>

### mixins

- **Тип:** `Array<Object>`

- **Подробности:**

  Массив объектов-миксинов. Миксины могут содержать те же опции, что и обычные объекты инстансов Vue — они будут добавлены к основным опциям согласно логике `Vue.extend()`. Например, если и миксин и объект оба содержат хук `created`, вызваны будут они оба.

  Хуки миксинов вызываются в порядке их определения, до вызова собственных хуков компонента.

- **Пример:**

  ``` js
  var mixin = {
    created: function () { console.log(1) }
  }
  var vm = new Vue({
    created: function () { console.log(2) },
    mixins: [mixin]
  })
  // -> 1
  // -> 2
  ```

- **См. также:** [Миксины](/guide/mixins.html)

### name

- **Тип:** `string`

- **Ограничение:** учитывается только при определении компонента.

- **Подробности:**

  Название компонента. Позволяет компоненту рекурсивно вызывать самого себя в шаблоне. Обратите внимание что когда компонент регистрируется глобально посредством `Vue.component()`, глобальный ID автоматически становится таким же, как и имя.

  Кроме того, компоненты с указанным `name` проще отлаживать из-за более понятных сообщений в консоли. В [vue-devtools](https://github.com/vuejs/vue-devtools) все безымянные компоненты довольно неинформативно называются `<AnonymousComponent>`. Когда у компонентов указано `name`, дерево компонентов становится куда понятнее.

### extends

- **Тип:** `Object | Function`

- **Подробности:**

  Позволяет декларативно наследоваться от другого компонента (который может быть либо простым объектом, либо конструктором), не используя `Vue.extend`. Главным образом предназначено для облегчения наследования между компонентами, определёнными в одном файле.

  Эта функциональность близка к `mixins`, с той разницей, что собственные опции компонента приоритетнее опций компонента, от которого происходит наследование.

- **Пример:**

  ``` js
  var CompA = { ... }

  // наследуем от CompA, не вызывая Vue.extend:
  var CompB = {
    extends: CompA,
    ...
  }
  ```

### delimiters

- **Тип:** `Array<string>`

- **По умолчанию:** `["{{", "}}"]`

- **Подробности:**

  Маркеры, выделяющие текст для интерполяции. **Доступно только в автономной сборке.**

- **Пример:**

  ``` js
  // меняем маркеры в шаблонах на свойственные ES6:

  new Vue({
    delimiters: ['${', '}']
  })
  ```

### functional

- **Тип:** `boolean`

- **Подробности:**

  Превращает компонент в функциональный, то есть не имеющий собственного состояния (`data`) и своего инстанса (`this`). Такие компоненты по сути — просто функция `render`, возвращающая узлы виртуального DOM. Это сильно ускоряет их рендер.

- **См. также:** [Функциональные компоненты](/guide/render-function.html#Functional-Components)

## Свойства инстанса

### vm.$data

- **Тип:** `Object`

- **Подробности:**

  Объект с данными, над которым инстанс Vue осуществляет наблюдение. Инстанс проксирует сюда вызовы своих полей. (Например, `vm.a` будет указывать на `vm.$data.a`)

- **См. также:** [Опции — данные](#data)

### vm.$el

- **Тип:** `HTMLElement`

- **Только для чтения**

- **Подробности:**

  Корневой элемент DOM, управляемый инстансом Vue.

### vm.$options

- **Тип:** `Object`

- **Только для чтения**

- **Подробности:**

  Опции, переданные в конструктор инстанса Vue. Полезно, если вы хотите передавать туда собственные опции:

  ``` js
  new Vue({
    customOption: 'что-нибудь',
    created: function () {
      console.log(this.$options.customOption) // -> 'что-нибудь'
    }
  })
  ```

### vm.$parent

- **Тип:** `инстанс Vue`

- **Только для чтения**

- **Подробности:**

  Инстанс-родитель, если он задан.

### vm.$root

- **Тип:** `инстанс Vue`

- **Только для чтения**

- **Подробности:**

  Корневой инстанс Vue текущего дерева компонентов. Если у инстанса нет родителя, в этом поле будет он сам.

### vm.$children

- **Тип:** `Array<инстанс Vue>`

- **Только для чтения**

- **Подробности:**

  Компоненты-потомки инстанса. **Обратите внимание, что порядок следования элементов в `$children` не гарантируется, и этот массив не реактивен.** Вместо того, чтобы использовать `$children` для связывания данных, попробуйте использовать обычный массив и директиву `v-for` для создания дочерних компонент, и используйте этот массив как "источник истины".

### vm.$slots

- **Тип:** `Object`

- **Только для чтения**

- **Подробности:**

  Используется для доступа к контенту, [распространяемому слотами](/guide/components.html#Content-Distribution-with-Slots). У каждого [именованного слота](/guide/components.html#Named-Slots) есть соответствующее значение в хэше (например, содержимое `slot="foo"` попадёт в `vm.$slots.foo`). Свойство `default` содержит узлы, не включённые в именованные слоты.

  Особенно полезно `vm.$slots` в компонентах с [render-функциями](/guide/render-function.html).

- **Пример:**

  ```html
  <blog-post>
    <h1 slot="header">
      Обо мне
    </h1>

    <p>Этот контент попадёт в vm.$slots.default, потому что он не в именованном слоте.</p>

    <p slot="footer">
      Copyright 2016 Evan You
    </p>

    <p>Этот контент тоже попадёт в vm.$slots.default.</p>.
  </blog-post>
  ```

  ```js
  Vue.component('blog-post', {
    render: function (createElement) {
      var header = this.$slots.header
      var body   = this.$slots.default
      var footer = this.$slots.footer
      return createElement('div', [
        createElement('header', header)
        createElement('main', body)
        createElement('footer', footer)
      ])
    }
  })
  ```

- **См. также:**
  - [Компонент `<slot>`](#slot)
  - [Дистрибьюция контента слотами](/guide/components.html#Content-Distribution-with-Slots)
  - [Render-функции](/guide/render-function.html)

### vm.$refs

- **Тип:** `Object`

- **Только для чтения**

- **Подробности:**

  Объект, с дочерними компонентами, имеющими параметр `ref`.

- **См. также:**
  - [Ссылки на дочерние компоненты](/guide/components.html#Child-Component-Refs)
  - [ref](#ref)

### vm.$isServer

- **Тип:** `boolean`

- **Только для чтения**

- **Подробности:**

  Запущен ли данный инстанс Vue на сервере.

- **См. также:** [Рендер на сервере](/guide/ssr.html)

## Методы инстанса — данные

<h3 id="vm-watch">vm.$watch( expOrFn, callback, [options] )</h3>

- **Аргументы:**
  - `{string | Function} expOrFn`
  - `{Function} callback`
  - `{Object} [options]`
    - `{boolean} deep`
    - `{boolean} immediate`

- **Возвращает:** `{Function} unwatch`

- **Использование:**

  Запускает слежение за выражением или вычисляемой функцией на предмет изменений. В параметры коллбэка будут переданы новые и старые значения отслеживаемого объекта. Выражение может быть как просто путём до переменной или любым другим выражением пригодным для связывания.

<p class="tip">Обратите внимание: когда мы изменяете (а не заменяете) объект или массив, старое и новое значения при вызове коллбэка будут совпадать, так как они ссылаются на один и тот же объект или массив. Vue не сохраняяет копии объекта на момент, предшествовавший изменениям.</p>

- **Пример:**

  ``` js
  // следим за переменной, указанной путём:
  vm.$watch('a.b.c', function (newVal, oldVal) {
    // переменная изменилась, сделайте что-нибудь
  })

  // следим за выражением:
  vm.$watch('a + b', function (newVal, oldVal) {
    // выражение изменилось, сделайте что-нибудь
  })

  // следим за функцией:
  vm.$watch(
    function () {
      return this.a + this.b
    },
    function (newVal, oldVal) {
      // значение функции изменилось, сделайте что-нибудь
    }
  )
  ```

  `vm.$watch` возвращает функцию unwatch, которая останавливает слежение:

  ``` js
  var unwatch = vm.$watch('a', cb)
  // позднее, останавливаем слежение:
  unwatch()
  ```

- **Опция: deep**

  Чтобы слежение реагировало на изменения во вложенных объектах, передайте `deep: true` в параметре options. Обратите внимание, что для наблюдения за изменениями массивов этого не требуется.

  ``` js
  vm.$watch('someObject', callback, {
    deep: true
  })
  vm.someObject.nestedValue = 123
  // вызывается callback
  ```

- **Опция: immediate**

  Если передано `immediate: true`, коллбэк будет вызван сразу же после начала слежения с текущим значением выражения:

  ``` js
  vm.$watch('a', callback, {
    immediate: true
  })
  // callback вызывается сразу, с текущим значением `a`
  ```

<h3 id="vm-set">vm.$set( object, key, value )</h3>

- **Аргументы:**
  - `{Object} object`
  - `{string} key`
  - `{any} value`

- **Возвращает:** установленное значение.

- **Использование:**

  **Алиас** глобального метода `Vue.set`.

- **См. также:** [Vue.set](#Vue-set)

<h3 id="vm-delete">vm.$delete( object, key )</h3>

- **Аргументы:**
  - `{Object} object`
  - `{string} key`

- **Использование:**

  **Алиас** глобального метода `Vue.delete`.

- **См. также:** [Vue.delete](#Vue-delete)

## Методы инстанса — cобытия

<h3 id="vm-on">vm.$on( event, callback )</h3>

- **Аргументы:**
  - `{string} event`
  - `{Function} callback`

- **Использование:**

  Реагирует на пользовательское событие текущего vm. Такое событие можно вызвать функцией `vm.$emit`. Коллбэк получит все дополнительные аргументы, переданные этому методу.

- **Пример:**

  ``` js
  vm.$on('test', function (msg) {
    console.log(msg)
  })
  vm.$emit('test', 'привет')
  // -> "привет"
  ```

<h3 id="vm-once">vm.$once( event, callback )</h3>

- **Аргументы:**
  - `{string} event`
  - `{Function} callback`

- **Использование:**

  Реагирует на пользовательское событие один раз. После первого использования слушатель будет удалён.

<h3 id="vm-off">vm.$off( [event, callback] )</h3>

- **Аргументы:**
  - `{string} [event]`
  - `{Function} [callback]`

- **Использование:**

  Удаляет слушателя или слушателей.

  - Если функция вызвана без параметров, она удалит все подписки на события;

  - Если указан только тип события — удалит все подписки указанного события;

  - Если указан и тип события, и коллбэк — будет удалена именно эта подписка именно этого события.

<h3 id="vm-emit">vm.$emit( event, [...args] )</h3>

- **Аргументы:**
  - `{string} event`
  - `[...args]`

  Вызывает событие в текущем инстансе. Все дополнительно указанные параметры будут переданы в коллбэк подписки.

## Instance Methods / Lifecycle

<h3 id="vm-mount">vm.$mount( [elementOrSelector] )</h3>

- **Аргументы:**
  - `{Element | string} [elementOrSelector]`
  - `{boolean} [hydrating]`

- **Returns:** `vm` - сам инстанс

- **Использование:**

  Если при создании инстанса Vue не была указана опция `el`, он будет находится в "несмонтированном" ("unmounted") состоянии, без ассоциированного элемента DOM. `vm.$mount()` может быть использовано, чтобы вручную примонтировать несмонтированный инстанс Vue.

  Если параметр `elementOrSelector` не указан, шаблон будет отрендерен как элемент вне документа (off-document element), и для вставки в документ вам придётся самостоятельно использовать нативное DOM API.

  Метод возвращает сам инстанс, что позволяет вызывать дополнительные методы по цепочке.

- **Пример:**

  ``` js
  var MyComponent = Vue.extend({
    template: '<div>Hello!</div>'
  })

  // создать и примонировать в #app (заменит #app)
  new MyComponent().$mount('#app')

  // будет иметь тот же эффект что и запись выше:
  new MyComponent({ el: '#app' })

  // или, возможен рендеринг вне документа, с последующей вставкой:
  var component = new MyComponent().$mount()
  document.getElementById('app').appendChild(component.$el)
  ```

- **См. также:**
  - [Диаграмма Жизненного Цикла](/guide/instance.html#Lifecycle-Diagram)
  - [Рендеринг на Сервере](/guide/ssr.html)

<h3 id="vm-forceUpdate">vm.$forceUpdate()</h3>

- **Использование:**

  Заставляет инстанс Vue произвести ререндеринг. Обратите внимание, что это действие не распространяется на все дочерние компоненты, а только на сам инстанс и дочерние компоненты со слотами контента.

<h3 id="vm-nextTick">vm.$nextTick( callback )</h3>

- **Аргументы:**
  - `{Function} callback`

- **Использование:**

  Откладывает callback на следующую итерацию цикла обновления DOM. Используйте непосредственно после того как вносите изменения в данные, чтобы подождать обновления DOM. Совпадает с глобальным `Vue.nextTick`, за исключением автоматического связывания контекстной переменной `this` с вызывающим инстансом.

- **Пример:**

  ``` js
  new Vue({
    // ...
    methods: {
      // ...
      example: function () {
        // изменение данных
        this.message = 'changed'
        // DOM ещё не обновлён
        this.$nextTick(function () {
          // теперь DOM обновлён
          // `this` указывает на текущий инстанс
          this.doSomethingElse()
        })
      }
    }
  })
  ```

- **См. также:**
  - [Vue.nextTick](#Vue-nextTick)
  - [Очередь Асинхронных Обновлений](/guide/reactivity.html#Async-Update-Queue)

<h3 id="vm-destroy">vm.$destroy()</h3>

- **Использование:**

  Полностью уничтожает vm. Очищает связи с другими существующими vm, отвязывает директивы, выключает все слушатели событий.

  Вызывает хуки `beforeDestroy` и `destroyed`.

  <p class="tip">В нормальных вариантах использования вам не придётся вызывать этот метод самим. Предпочтительнее контроллировать жизненный цикл дочерних компонент в data-driven стиле, использую `v-if` и `v-for`.</p>

- **См. также:** [Диаграмма Жизненного Цикла](/guide/instance.html#Lifecycle-Diagram)

## Директивы

### v-text

- **Ожидает:** `string`

- **Подробности:**

  Обновляет `textContent` элемента. Если необходимо обновить часть `textContent`, используйте интерполяцию `{% raw %}{{ Mustache }}{% endraw %}`.

- **Пример:**

  ```html
  <span v-text="msg"></span>
  <!-- то же, что -->
  <span>{{msg}}</span>
  ```

- **См. также:** [Синтаксис Связывания Данных - интерполяции](/guide/syntax.html#Text)

### v-html

- **Ожидает:** `string`

- **Подробности:**

  Обновляет `innerHTML` элемента. **Обратите внимание, что содержимое вставляется как обычный HTML — то есть не компилируется как шаблон Vue**. Если вы обнаружите себя за попытками организации вложенных компонент при помощи `v-html`, попробуйте вместо этого применить компоненты.

  <p class="tip">Динамический рендеринг произвольного HTML-кода на сайте может быть очень опасным, так как легко приводит к [XSS атакам](https://en.wikipedia.org/wiki/Cross-site_scripting). Используйте `v-html` только на доверенном контенте, и **никогда** — на предоставляемом пользователями.</p>

- **Пример:**

  ```html
  <div v-html="html"></div>
  ```
- **См. также:** [Синтаксис Связывания Данных - интерполяции](/guide/syntax.html#Raw-HTML)

### v-if

- **Ожидает:** `any`

- **Использование:**

  В зависимости от истинности значения указанного выражения, рендерит (или нет) элемент. Элемент и содержащиеся в нём директивы / компоненты уничтожаются и заново создаются при переключениях. Для фиктивного элемента `<template>` в качестве результирующего условного блока используется внутреннее содержимое.

  Эта директива вызывает transitions при изменении состояния.

- **См. также:** [Условный Рендеринг - v-if](/guide/conditional.html)

### v-show

- **Ожидает:** `any`

- **Использование:**

  Переключает CSS-свойство `display` элемента, в зависимости от истинности значения указанного выражения.

  Эта директива вызывает transitions при изменении состояния.


- **См. также:** [Условный Рендеринг - v-show](/guide/conditional.html#v-show)

### v-else

- **Не ожидает какого-либо выражения**

- **Ограничение:** предыдущий элемент должен иметь директиву `v-if`.

- **Использование:**

  Определяет "блок else" для `v-if`.

  ```html
  <div v-if="Math.random() > 0.5">
    Сейчас меня видно
  </div>
  <div v-else>
    А сейчас — нет
  </div>
  ```

- **См. также:**
  - [Условный Рендеринг - v-else](/guide/conditional.html#v-else)

### v-for

- **Ожидает:** `Array | Object | number | string`

- **Использование:**

  Рендерит элемент или блок шаблона многократно, основываясь на указанных данных. Значение директивы должно следовать особому синтаксису ` alias in expression` чтобы использовать alias для доступа к элементу данной итерации:

  ``` html
  <div v-for="item in items">
    {{ item.text }}
  </div>
  ```

  Альтернативным образом, вы можете также указать алиас для индекса (или ключа, при использовании с Объектами):

  ``` html
  <div v-for="(item, index) in items"></div>
  <div v-for="(val, key) in object"></div>
  <div v-for="(val, key, index) in object"></div>
  ```

  По умолчанию `v-for` будет пытаться обновить элементы "на месте", не перемещая их. Для явного указания необходимости перемещения, используйте специальный атрибут `key`:

  ``` html
  <div v-for="item in items" :key="item.id">
    {{ item.text }}
  </div>
  ```

  Использование `v-for` подробно описано в нижеуказанной секции Руководства.

- **См. также:**
  - [Рендеринг Списков](/guide/list.html)
  - [key](/guide/list.html#key)

### v-on

- **Сокращение:** `@`

- **Ожидает:** `Function | Inline Statement`

- **Параметр:** `event (указание обязательно)`

- **Модификаторы:**
  - `.stop` - вызовет `event.stopPropagation()`.
  - `.prevent` - вызовет `event.preventDefault()`.
  - `.capture` - добавит слушатель в "capture mode".
  - `.self` - вызовет обработчик только в случае возникновения события непосредственно на этом элементе.
  - `.{keyCode | keyAlias}` - вызывает обработчик только при нажатии определённой клавиши.
  - `.native` - слушать нативное событие на корневом элементе компонента.

- **Использование:**

  Прикрепляет к элементу слушателя события. Тип события указывается в параметре. Выражение может быть как именем метода, так и inline-выражением, или вовсе отсутствовать, если указан модификатор(ы).

  При использовании на обычном элементе, слушает только **нативные события DOM**. При использовании на элементе пользовательского компонента, слушает также **пользовательские события**, эмитируемые этим дочерним компонентом.

  При слушании нативных событий DOM, метод получает нативное событие единственным аргументом. При использовании inline-выражений, выражение имеет доступ к специальному свойству `$event`: `v-on:click="handle('ok', $event)"`.

- **Пример:**

  ```html
  <!-- обработчик метода -->
  <button v-on:click="doThis"></button>

  <!-- inline-выражение -->
  <button v-on:click="doThat('hello', $event)"></button>

  <!-- сокращение -->
  <button @click="doThis"></button>

  <!-- модификатор stop propagation -->
  <button @click.stop="doThis"></button>

  <!-- модификатор prevent default -->
  <button @click.prevent="doThis"></button>

  <!-- модификатор prevent default без дополнительных действий -->
  <form @submit.prevent></form>

  <!-- цепочка из модификаторов -->
  <button @click.stop.prevent="doThis"></button>

  <!-- модификатор клавиши keyAlias -->
  <input @keyup.enter="onEnter">

  <!-- модификатор клавиши keyCode -->
  <input @keyup.13="onEnter">
  ```

  Слушание пользовательских события на дочернем элементе (обработчик вызывается, когда в дочерний элемент эмитирует "my-event"):

  ```html
  <my-component @my-event="handleThis"></my-component>

  <!-- inline-выражение -->
  <my-component @my-event="handleThis(123, $event)"></my-component>

  <!-- слушать нативное событие в компоненте -->
  <my-component @click.native="onClick"></my-component>
  ```

- **См. также:**
  - [Методы и Обработка Событий](/guide/events.html)
  - [Компоненты - Пользовательские События](/guide/components.html#Custom-Events)

### v-bind

- **Сокращение:** `:`

- **Ожидает:** `any (with argument) | Object (without argument)`

- **Параметр:** `attrOrProp (optional)`

- **Модификаторы:**
  - `.prop` - Используется для связывания DOM-аттрибутов.

- **Использование:**

  Динамически связывает один или более аттрибут, или входной параметр компонента с выражением.

  При использовании с аттрибутами `class` и `style` поддерживает дополнительные типы значений, а именно массивы и объекты. См. секцию руководства по ссылке ниже для подробностей.

  При использовании для связывания входных атрибутов, сам атрибут необходимо должным образом определить в дочернем компоненте.

  Если аргумент не указан, может быть использовано для связывания с объектом, содержащим пары имя-значение. Обратите внимания, что в этом случае атрибуты `class` и `style` не поддерживают массивы и объекты.

- **Пример:**

  ```html
  <!-- связывание атрибута -->
  <img v-bind:src="imageSrc">

  <!-- сокращение -->
  <img :src="imageSrc">

  <!-- связывание css-класса -->
  <div :class="{ red: isRed }"></div>
  <div :class="[classA, classB]"></div>
  <div :class="[classA, { classB: isB, classC: isC }]">

  <!-- связывание локального стиля -->
  <div :style="{ fontSize: size + 'px' }"></div>
  <div :style="[styleObjectA, styleObjectB]"></div>

  <!-- связывание с объектом, содержащим атрибуты -->
  <div v-bind="{ id: someProp, 'other-attr': otherProp }"></div>

  <!-- связывание с атрибутами DOM при указании модификатора -->
  <div v-bind:text-content.prop="text"></div>

  <!-- связывание входного параметра. "prop" должен быть определён в my-component. -->
  <my-component :prop="someThing"></my-component>

  <!-- XLink -->
  <svg><a :xlink:special="foo"></a></svg>
  ```

- **См. также:**
  - [Связывание Классов и Стилей](/guide/class-and-style.html)
  - [Компоненты - Входные Параметры Компонентов](/guide/components.html#Props)

### v-model

- **Ожидает:** варьируется в зависимости от значения элементов форм или выходных данных компонентов

- **Используется только с:**
  - `<input>`
  - `<select>`
  - `<textarea>`
  - components

- **Модификаторы:**
  - [`.lazy`](/guide/forms.html#lazy) - слушать события `change`, а не `input`
  - [`.number`](/guide/forms.html#number) - приводить введённую строку к числу
  - [`.trim`](/guild/forms.html#trim) - удалять пробелы в начале и в конце введённой строки

- **Использование:**

  Двусторонним образом связывает элемент ввода формы или компонент с переменной. См. секцию руководства по ссылке ниже для подробностей.

- **См. также:**
  - [Связывание Элементов Ввода Форм](/guide/forms.html)
  - [Компоненты - Компоненты Элементов Ввода Форм c Использованием Пользовательских Событий](/guide/components.html#Form-Input-Components-using-Custom-Events)

### v-pre

- **Не ожидает выражения**

- **Использование:**

  Пропустить компиляцию для этого элемента и всех его потомков. Вы можете использовать это для отображения необработанных тегов `{{}}`. Пропуск большого количества элементов может также ускорить компиляцию.

- **Пример:**

  ```html
  <span v-pre>{{ this will not be compiled }}</span>
   ```

### v-cloak

- **Не ожидает выражения**

- **Использование:**

  Эта директива останется на элементе до тех пор пока ассоциированный инстанс Vue не закончит компиляцию. В сочетании с правилами CSS, такими как `[v-clock] { display: none }`, эта директива может быть использована чтобы спрятать нескомпилированные шаблоны до тех пор, пока инстанс Vue не будет готов.

- **Пример:**

  ```css
  [v-cloak] {
    display: none;
  }
  ```

  ```html
  <div v-cloak>
    {{ message }}
  </div>
  ```

  The `<div>` will not be visible until the compilation is done.

### v-once

- **Не ожидает выражения**

- **Подробности:**

  **Однократно** рендерит элемент или компонент. При последующих операциях ре-рендеринга элемент/компонент, а также все его потомки будет рассматриваться как статический контент и пропускаться. Это позволяет оптимизировать производительность обновлений.

  ```html
  <!-- одиночный элемент -->
  <span v-once>Это никогда не изменится: {{msg}}</span>
  <!-- элемент содержит потомков -->
  <div v-once>
    <h1>comment</h1>
    <p>{{msg}}</p>
  </div>
  <!-- компонент -->
  <my-component v-once :comment="msg"></my-component>
  <!-- директива v-for -->
  <ul>
    <li v-for="i in list" v-once>{{i}}</li>
  </ul>
  ```

- **См. также:**
  - [Синтаксис Связывания Данных - интерполяции](/guide/syntax.html#Text)
  - [Компоненты - Дешёвые Статические Компоненты с использованием v-once](/guide/components.html#Cheap-Static-Components-with-v-once)

## Специальные Аттрибуты

### key

- **Ожидает:** `string`

  Специальный аттрибут `key` главным образом используется алгоритмом работы с virtual DOM Vue как подсказка для определения VNode'ов при сравнении нового и старого списков узлов. Если аттрибут ключа не указан, Vue использует алгоритм, минимизирующий перемещение элементов и старается обновить/повторно использовать элементы того же типа "на местах" максимально насколько это возможно. Если ключ указан, Vue изменяет порядок следования элементов, основываясь на изменении порядка ключей, а элементы, соотвествующие более не используемым ключам всегда удаляются/уничтожаются.

  Потомки одного и того же общего родителя должны иметь **уникальные ключи**. Повторяющиеся ключи приведут к ошибкам рендеринга.

  В основном используется в связке с `v-for`:

  ``` html
  <ul>
    <li v-for="item in items" :key="item.id">...</li>
  </ul>
  ```

  Может также использоваться для принудительной замены элемента/компонента вместо повторого его использования, что может быть полезным, если вы хотите:

  - Быть уверенны, что все хуки жизненного цикла компонента будут вызваны
  - Запустить анимации переходов (transitions)

  Например:

  ``` html
  <transition>
    <span :key="text">{{ text }}</span>
  </transition>
  ```

  При изменении `text`, `<span>` всегда будет заменяться целиком, что спровоцирует вызов анимации перехода.

### ref

- **Ожидает:** `string`

  `ref` используется для регистрации ссылки на элемент или дочерний компонент. Ссылка будет зарегистрирована в объекте `$refs` родительского объекта. При использовании на простом элементе DOM, ссылка будет указывать на этот элемент; при использовании на дочернем компоненте, ссылка будет указывать на инсанс компонента:

  ``` html
  <!-- vm.$refs.p будет указывать на элемент DOM -->
  <p ref="p">hello</p>

  <!-- vm.$refs.child будет указывать на инстанс ChildComp -->
  <child-comp ref="child"></child-comp>
  ```

  При использовании на элементах/компонентах с `v-for`, регистрируется массив ссылок на элементы DOM или инстансы компонентов.

  Важное замечание о времени регистрации ссылок: поскольку ссылки сами создаются в результате работы render-функции, вы не можете использовать их при первичном рендеринге — на тот момент они ещё не существуют! Кроме того, объект `$refs` не является реактивным, и поэтому не стоит пытаться использовать его в шаблонах для связывания данных.

- **См. также:** [Ссылки на Дочерние Компоненты](/guide/components.html#Child-Component-Refs)

### slot

- **Ожидает:** `string`

  Используется в контенте дочерних компонент для указания того, к какому из именованных слотов этот контент принадлежит.

  См. секцию руководства по ссылке ниже для подробностей.

- **См. также:** [Именованные Слоты](/guide/components.html#Named-Slots)

## Built-In Компоненты

### component

- **Входные Параметры:**
  - `is` - string | ComponentDefinition | ComponentConstructor
  - `inline-template` - boolean

- **Использование:**

  "Метакомпонент" для рендеринга динамических компонентов. Настоящий компонент для рендеринга определяется параметром `is`:

  ```html
  <!-- динамический компонент, контроллируемый -->
  <!-- свойством `componentId` vm -->
  <component :is="componentId"></component>

  <!-- может также рендерить зарегистрированный или переданный через параметр компонент -->
  <component :is="$options.components.child"></component>
  ```

- **См. также:** [Динамические Компоненты](/guide/components.html#Dynamic-Components)

### transition

- **Входные Параметры:**
  - `name` - string, Используется для автоматической генерации имён CSS-классов для переходов. Например, `name: 'fade'` автоматически раскроется в `.fade-enter`, `.fade-enter-active`, etc. Значение по умолчанию — `"v"`.
  - `appear` - boolean, Вызывать ли анимацию при первичном рендеринге. По умолчанию `false`.
  - `css` - boolean, Применять ли CSS-классы. По умолчанию `true`. Если установить в `false`, будут вызываться только хуки JavaScript, зарегистрированные для событий компонента.
  - `type` - string, Указывает тип ожидаемых событий перехода для определения момента завершения перехода. Доступные значения: `"transition"` и `"animation"`. По умолчанию, автоматически определяется тип, задающий наибольшую продолжительность.
  - `mode` - string, Управляет временным порядком переходов исчезновения/появления элемента. Доступные режимы `"out-in"` и `"in-out"`; по умолчанию оба процесса происходят одновременно.
  - `enter-class` - string
  - `leave-class` - string
  - `enter-active-class` - string
  - `leave-active-class` - string
  - `appear-class` - string
  - `appear-active-class` - string

- **Events:**
  - `before-enter`
  - `enter`
  - `after-enter`
  - `before-leave`
  - `leave`
  - `after-leave`
  - `before-appear`
  - `appear`
  - `after-appear`

- **Использование:**

  `<transition>` служит для указания эффектов перехода для **одиночного** элемента/компонента. `<transition>` не порождает дополнительного элемента DOM при рендеринге, а равно и не отображается в иерархии компонентов в инспекторе. Этот компонент просто применяет поведение перехода к своему содержимому.

  ```html
  <!-- простой элемент -->
  <transition>
    <div v-if="ok">переключаемое содержимое</div>
  </transition>

  <!-- динамический компонент -->
  <transition name="fade" mode="out-in" appear>
    <component :is="view"></component>
  </transition>

  <!-- хук на событие -->
  <div id="transition-demo">
    <transition @after-enter="transitionComplete">
      <div v-show="ok">toggled content</div>
    </transition>
  </div>
  ```

  ``` js
  new Vue({
    ...
    methods: {
      transitionComplete: function (el) {
        // сделать что-то с переданным как el елементом DOM ...
      }
    }
    ...
  }).$mount('#transition-demo')
  ```

- **См. также:** [Анимации Переходов: Появление, Исчезновение, и Списки](/guide/transitions.html)

### transition-group

- **Входные Параметры:**
  - `tag` - string, по умолчанию используется `span`.
  - `move-class` - переопределяет CSS-класс, применяемый во время анимации перемещения.
  - те же аттрибуты, что и у `<transition>`, за исключением `mode`.

- **Events:**
  - те же, что и у `<transition>`.

- **Использование:**

  `<transition-group>` служит as для указания эффектов перехода для **нескольких** элементов/компонентов. `<transition-group>` превращается в реальный элемент DOM. По умолчанию используется тег `<span>`, что может быть изменено параметром `tag`.

  Обратите внимание, что каждый потомок `<transition-group>` должен иметь **уникальный ключ**, чтобы анимации работали корректно.

  `<transition-group>` поддерживает анимации перехода посредством CSS-трансформаций. Когда позиция потомка изменилась после обновления, будет применён указывающий на перемещение CSS-класс (автоматически сгенерированный из аттрибута `name`, или же явно указанный через аттрибут `move-class`). Если свойство CSS `transform` поддерживает анимацию перехода "transition-able" для этого класса, будет произведена гладкая анимация элемента в соответствии с [техникой FLIP](https://aerotwist.com/blog/flip-your-animations/).

  ```html
  <transition-group tag="ul" name="slide">
    <li v-for="item in items" :key="item.id">
      {{ item.text }}
    </li>
  </transition-group>
  ```

- **См. также:** [Анимации Переходов: Появление, Исчезновение, и Списки](/guide/transitions.html)

### keep-alive

- **Использование:**

  Используемая как обёртка для динамических компонентов, `<keep-alive>` кеширует инстансы интерактивных компонентов, не уничтожая их. Так же, как и `<transition>`, `<keep-alive>` является абстрактным компонентом: при рендеринге сама она не превращается в элемент DOM, а равно не показывается и в цепочке родителей компонента.

  Когда отображение компонента, расположенного внутри `<keep-alive>` переключается, вызываются его хуки жизненного цикла `activated` или `deactivated` соответственно.

  В основном используется для сохранения состояния компонента во избежания повторного рендеринга.

  ```html
  <!-- базовый вариант -->
  <keep-alive>
    <component :is="view"></component>
  </keep-alive>

  <!-- несколько потомков -->
  <keep-alive>
    <comp-a v-if="a > 1"></comp-a>
    <comp-b v-else></comp-b>
  </keep-alive>

  <!-- использование совместно с <transition> -->
  <transition>
    <keep-alive>
      <component :is="view"></component>
    </keep-alive>
  </transition>
  ```

  <p class="tip">`<keep-alive>` не работает с функциональными компонентами, так как у них отсутсвуют инстансы.</p>

- **См. также:** [Динамические Компоненты - keep-alive](/guide/components.html#keep-alive)

### slot

- **Входные Параметры:**
  - `name` - string, Используется для именования слотов

- **Использование:**

  `<slot>` служит гнездом для последующей дистрибуции контента в шаблонах компонентов. Сам элемент `<slot>` при рендеринге заменяется.

  См. секцию руководства по ссылке ниже для подробностей.

- **См. также:** [Дистрибьюция Контента посредством Слотов](/guide/components.html#Content-Distribution-with-Slots)

## Интерфейс VNode

- Пожалуйста, обратитесь к информации об [объявлении классов VNode](https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js).

## Рендеринг на стороне сервера

- Пожалуйста, обратитесь к [документации пакета vue-server-renderer](https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer).
